{"version":3,"sources":["../../src/ethereum_virtual_machine.ts"],"sourcesContent":["import { \r\n    Unsafe,\r\n    Option,\r\n    Result,\r\n    Some,\r\n    None,\r\n    Ok,\r\n    Err,\r\n    Fpv,\r\n    flag,\r\n    wrap,\r\n    wrapAsync\r\n} from \"@tokyo/reliq\";\r\nimport { \r\n    type BaseContract,\r\n    type ContractMethod,\r\n    type TransactionResponse,\r\n    type TransactionReceipt,\r\n    Contract,\r\n    ContractFactory,\r\n    Interface,\r\n    JsonRpcProvider,\r\n    Wallet\r\n} from \"ethers\";\r\n\r\ntype _Result$0<T1, T2> = Result<T1, T2>;\r\n\r\ntype _TransactionResponse$0 = TransactionResponse;\r\n\r\ntype _TransactionReceipt$0 = TransactionReceipt;\r\n\r\nexport type EthereumVirtualMachine = {\r\n    query<T1 = unknown, T2 extends EthereumVirtualMachine.Payload<T1> = EthereumVirtualMachine.Payload<T1>>(transaction: EthereumVirtualMachine.Query<T1, T2>): Promise<EthereumVirtualMachine.Result<Unsafe>>;\r\n    touch<T1 = unknown, T2 extends EthereumVirtualMachine.Payload<T1> = EthereumVirtualMachine.Payload<T1>>(transaction: EthereumVirtualMachine.Touch<T1, T2>): Promise<EthereumVirtualMachine.Result<Option<EthereumVirtualMachine.TransactionReceipt>>>;\r\n    deploy<T1 = unknown, T2 extends EthereumVirtualMachine.Payload<T1> = EthereumVirtualMachine.Payload<T1>>(transaction: EthereumVirtualMachine.Deployment<T1, T2>): Promise<EthereumVirtualMachine.Result<EthereumVirtualMachine.Address>>;\r\n};\r\n\r\nexport function EthereumVirtualMachine(_url: string): EthereumVirtualMachine.Result<EthereumVirtualMachine> {\r\n    let _jsonRpcProvider: JsonRpcProvider;\r\n\r\n    /** @constructor */ {\r\n        let jsonRpcProvider: EthereumVirtualMachine.Result<JsonRpcProvider> = _map(wrap(() => {\r\n            return new JsonRpcProvider(_url);\r\n        }));\r\n        if (jsonRpcProvider.err()) return jsonRpcProvider;\r\n        _jsonRpcProvider = jsonRpcProvider.unwrap();\r\n        return Ok({ query, touch, deploy });\r\n    }\r\n\r\n    async function query<T1 = unknown, T2 extends EthereumVirtualMachine.Payload<T1> = EthereumVirtualMachine.Payload<T1>>(transaction: EthereumVirtualMachine.Query<T1, T2>): Promise<EthereumVirtualMachine.Result<Unsafe>> {\r\n        let wallet: EthereumVirtualMachine.Result<Wallet> = _map(wrap(() => {\r\n            return new Wallet(transaction.privateKey, _jsonRpcProvider);\r\n        }));\r\n        if (wallet.err()) return wallet;\r\n        let wallet$0: Wallet = wallet.unwrap();\r\n        let contract: EthereumVirtualMachine.Result<Contract> = _map(wrap(() => {\r\n            return new Contract(transaction.to, [transaction.signature], wallet$0);\r\n        }));\r\n        if (contract.err()) return contract;\r\n        let contract$0: Contract = contract.unwrap();\r\n        let contractMethod: EthereumVirtualMachine.Result<ContractMethod> = _map(wrap(() => {\r\n            return contract$0.getFunction(transaction.signature);\r\n        }));\r\n        if (contractMethod.err()) return contractMethod;\r\n        let contractMethod$0: ContractMethod = contractMethod.unwrap();\r\n        let response: EthereumVirtualMachine.Result<Unsafe> = await _map(wrapAsync(async () => {\r\n            return Unsafe(await contractMethod$0(...transaction.payload ?? []));\r\n        }));\r\n        if (response.err()) return response;\r\n        let response$0: Unsafe = response.unwrap();\r\n        return Ok(response$0);\r\n    }\r\n\r\n    async function touch<T1 = unknown, T2 extends EthereumVirtualMachine.Payload<T1> = EthereumVirtualMachine.Payload<T1>>(transaction: EthereumVirtualMachine.Touch<T1, T2>): Promise<EthereumVirtualMachine.Result<Option<EthereumVirtualMachine.TransactionReceipt>>> {\r\n        let wallet: EthereumVirtualMachine.Result<Wallet> = _map(wrap(() => {\r\n            return new Wallet(transaction.privateKey, _jsonRpcProvider);\r\n        }));\r\n        if (wallet.err()) return wallet;\r\n        let wallet$0: Wallet = wallet.unwrap();\r\n        let address: EthereumVirtualMachine.Result<EthereumVirtualMachine.Address> = await _map(wrapAsync(async () => {\r\n            return await wallet$0.getAddress() as EthereumVirtualMachine.Address;\r\n        }));\r\n        if (address.err()) return address;\r\n        let address$0: EthereumVirtualMachine.Address = address.unwrap();\r\n        let nonce: EthereumVirtualMachine.Result<bigint> = await _map(wrapAsync(async () => {\r\n            return BigInt(await wallet$0.getNonce());\r\n        }));\r\n        if (nonce.err()) return nonce;\r\n        let nonce$0: bigint = nonce.unwrap();\r\n        let interface$0: EthereumVirtualMachine.Result<Interface> = _map(wrap(() => {\r\n            return new Interface([transaction.signature]);\r\n        }));\r\n        if (interface$0.err()) return interface$0;\r\n        let interface$1: Interface = interface$0.unwrap();\r\n        let name: Option<string> = EthereumVirtualMachine.Signature.nameOf(transaction.signature);\r\n        if (name.none()) return Err({\r\n            code: \"ETHEREUM_VIRTUAL_MACHINE.ERR_MALFORMED_SIGNATURE\",\r\n            data: None,\r\n            message: None,\r\n            reason: None,\r\n            transaction: None\r\n        });\r\n        let name$0: string = name.unwrap();\r\n        let data: EthereumVirtualMachine.Result<string> = _map(wrap(() => {\r\n            return interface$1.encodeFunctionData(name$0, transaction.payload);\r\n        }));\r\n        if (data.err()) return data;\r\n        let data$0: string = data.unwrap();\r\n        let gasPrice: bigint = transaction.gasPrice ? Fpv.Calculator.unwrap(transaction.gasPrice) : 0n;\r\n        let gasLimit: bigint = transaction.gasLimit ? Fpv.Calculator.unwrap(transaction.gasLimit) : 0n;\r\n        let response: EthereumVirtualMachine.Result<EthereumVirtualMachine.TransactionResponse | null> = await _map(wrapAsync(async () => {\r\n            return await wallet$0.sendTransaction({\r\n                from: address$0,\r\n                to: transaction.to,\r\n                nonce: Number(nonce$0),\r\n                gasPrice: gasPrice,\r\n                gasLimit: gasLimit,\r\n                data: data$0\r\n            });\r\n        }));\r\n        if (response.err()) return response;\r\n        let response$0: EthereumVirtualMachine.TransactionResponse | null = response.unwrap();\r\n        if (response$0 === null) return Err({\r\n            code: \"ETHEREUM_VIRTUAL_MACHINE.ERR_INVALID_RESPONSE\",\r\n            data: None,\r\n            message: None,\r\n            transaction: None,\r\n            reason: None\r\n        });\r\n        let receipt: EthereumVirtualMachine.Result<EthereumVirtualMachine.TransactionReceipt | null> = await _map(wrapAsync(async () => {\r\n            return await response$0.wait(Number(transaction.confirmations), Number(transaction.timeout));\r\n        }));\r\n        if (receipt.err()) return receipt;\r\n        let receipt$0: EthereumVirtualMachine.TransactionReceipt | null = receipt.unwrap();\r\n        if (receipt$0 === null) return Ok(None);\r\n        return Ok(Some(receipt$0));\r\n    }\r\n\r\n    async function deploy<T1 = unknown, T2 extends EthereumVirtualMachine.Payload<T1> = EthereumVirtualMachine.Payload<T1>>(transaction: EthereumVirtualMachine.Deployment<T1, T2>): Promise<EthereumVirtualMachine.Result<EthereumVirtualMachine.Address>> {        \r\n        let wallet: EthereumVirtualMachine.Result<Wallet> = _map(wrap(() => {\r\n            return new Wallet(transaction.privateKey, _jsonRpcProvider);\r\n        }));\r\n        if (wallet.err()) return wallet;\r\n        let wallet$0: Wallet = wallet.unwrap();\r\n        let contractFactory: EthereumVirtualMachine.Result<ContractFactory> = _map(wrap(() => {\r\n            return new ContractFactory(transaction.abi, transaction.bytecode, wallet$0);\r\n        }));\r\n        if (contractFactory.err()) return contractFactory;\r\n        let contractFactory$0: ContractFactory = contractFactory.unwrap();\r\n        let contract: EthereumVirtualMachine.Result<BaseContract> = await _map(wrapAsync(async () => {\r\n            return await contractFactory$0.deploy(transaction.payload);\r\n        }));\r\n        if (contract.err()) return contract;\r\n        let contract$0: BaseContract = contract.unwrap();\r\n        let address: EthereumVirtualMachine.Result<EthereumVirtualMachine.Address> = await _map(wrapAsync(async () => {\r\n            return await contract$0.getAddress() as EthereumVirtualMachine.Address;\r\n        }));\r\n        if (address.err()) return address;\r\n        let address$0: EthereumVirtualMachine.Address = address.unwrap();\r\n        return Ok(address$0);\r\n    }\r\n\r\n    function _map<T1>(result: Promise<_Result$0<T1, Unsafe>>): Promise<EthereumVirtualMachine.Result<T1>>;\r\n    function _map<T1>(result: _Result$0<T1, Unsafe>): EthereumVirtualMachine.Result<T1>;\r\n    function _map<T1>(unsafe: Unsafe): EthereumVirtualMachine.Error;\r\n    function _map<T1>(\r\n        p0: \r\n            | Promise<_Result$0<T1, Unsafe>>\r\n            | _Result$0<T1, Unsafe> \r\n            | Unsafe\r\n    ): \r\n        | Promise<EthereumVirtualMachine.Result<T1>>\r\n        | EthereumVirtualMachine.Result<T1> \r\n        | EthereumVirtualMachine.Error {\r\n        if (\"then\" in p0) {\r\n            let result: Promise<_Result$0<T1, Unsafe>> = p0;\r\n            return result.then(result$0 => {\r\n                return _map(result$0);\r\n            });\r\n        }\r\n        if (\"ok\" in p0) {\r\n            let result: _Result$0<T1, Unsafe> = p0;\r\n            return result.mapErr(e => {\r\n                return _map(e);\r\n            });\r\n        }\r\n        let unsafe: Unsafe = p0;\r\n        let e: unknown = unsafe.inspect();\r\n        if (!(\r\n            e !== null\r\n            && e !== undefined\r\n            && typeof e === \"object\"\r\n            && \"code\" in e\r\n            && typeof e.code === \"string\"\r\n        )) return {\r\n            code: \"ETHEREUM_VIRTUAL_MACHINE.ERR_UNKNOWN\",\r\n            data: None,\r\n            message: None,\r\n            transaction: None,\r\n            reason: None\r\n        };\r\n        let code: EthereumVirtualMachine.ErrorCode =\r\n            e.code === \"UNKNOWN_ERROR\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_UNKNOWN\" :\r\n            e.code === \"NOT_IMPLEMENTED\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_NOT_IMPLEMENTED\" :\r\n            e.code === \"UNSUPPORTED_OPERATION\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_UNSUPPORTED_OPERATION\" :\r\n            e.code === \"NETWORK_ERROR\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_NETWORK_FAULT\" :\r\n            e.code === \"SERVER_ERROR\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_SERVER_FAULT\" :\r\n            e.code === \"TIMEOUT\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_TIMEOUT\" :\r\n            e.code === \"BAD_DATA\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_BAD_DATA\" :\r\n            e.code === \"CANCELLED\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_CANCELLED\" :\r\n            e.code === \"BUFFER_OVERRUN\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_BUFFER_OVERRUN\" :\r\n            e.code === \"NUMERIC_FAULT\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_NUMERIC_FAULT\" :\r\n            e.code === \"INVALID_ARGUMENT\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_INVALID_ARGUMENT\" :\r\n            e.code === \"MISSING_ARGUMENT\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_MISSING_ARGUMENT\" :\r\n            e.code === \"UNEXPECTED_ARGUMENT\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_UNEXPECTED_ARGUMENT\" :\r\n            e.code === \"CALL_EXCEPTION\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_CALL_EXCEPTION\" : \r\n            e.code === \"INSUFFICIENT_FUNDS\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_INSUFFICIENT_FUNDS\" :\r\n            e.code === \"NONCE_EXPIRED\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_NONCE_EXPIRED\" :\r\n            e.code === \"REPLACEMENT_UNDERPRICED\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_REPLACEMENT_UNDERPRICED\" :\r\n            e.code === \"TRANSACTION_REPLACED\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_TRANSACTION_REPLACED\" :\r\n            e.code === \"UNCONFIGURED_NAME\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_UNCONFIGURED_NAME\" :\r\n            e.code === \"OFFCHAIN_FAULT\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_OFFCHAIN_FAULT\" :\r\n            e.code === \"ACTION_REJECTED\" ? \"ETHEREUM_VIRTUAL_MACHINE.ERR_ACTION_REJECTED\" :\r\n            \"ETHEREUM_VIRTUAL_MACHINE.ERR_UNKNOWN\";\r\n        let data: Option<unknown> = None;\r\n        let message: Option<unknown> = None;\r\n        let transaction: Option<unknown> = None;\r\n        let reason: Option<unknown> = None;\r\n        if (\"data\" in e) data = Some(e.data);\r\n        if (\"message\" in e) data = Some(e.message);\r\n        if (\"transaction\" in e) data = Some(e.transaction);\r\n        if (\"reason\" in e) data = Some(e.reason);\r\n        return { code, data, message, transaction, reason };\r\n    }\r\n}\r\n\r\nexport namespace EthereumVirtualMachine {\r\n    export type Result<T1> = _Result$0<T1, Error>;\r\n\r\n    export type Error = {\r\n        code: ErrorCode;\r\n        data: Option<unknown>;\r\n        message: Option<unknown>;\r\n        transaction: Option<unknown>;\r\n        reason: Option<unknown>;\r\n    };\r\n\r\n    export type ErrorCode =\r\n        | `${ Brand }.ERR_MALFORMED_SIGNATURE`\r\n\r\n        /// Generic\r\n        | `${ Brand }.ERR_UNKNOWN`\r\n        | `${ Brand }.ERR_NOT_IMPLEMENTED`\r\n        | `${ Brand }.ERR_UNSUPPORTED_OPERATION`\r\n        | `${ Brand }.ERR_NETWORK_FAULT`\r\n        | `${ Brand }.ERR_SERVER_FAULT`\r\n        | `${ Brand }.ERR_TIMEOUT`\r\n        | `${ Brand }.ERR_BAD_DATA`\r\n        | `${ Brand }.ERR_CANCELLED`\r\n        | `${ Brand }.ERR_INVALID_RESPONSE`\r\n\r\n        /// Operational\r\n        | `${ Brand }.ERR_BUFFER_OVERRUN`\r\n        | `${ Brand }.ERR_NUMERIC_FAULT`\r\n\r\n        /// Argument\r\n        | `${ Brand }.ERR_INVALID_ARGUMENT`\r\n        | `${ Brand }.ERR_MISSING_ARGUMENT`\r\n        | `${ Brand }.ERR_UNEXPECTED_ARGUMENT`\r\n\r\n        /// Blockchain\r\n        | `${ Brand }.ERR_CALL_EXCEPTION`\r\n        | `${ Brand }.ERR_INSUFFICIENT_FUNDS`\r\n        | `${ Brand }.ERR_NONCE_EXPIRED`\r\n        | `${ Brand }.ERR_REPLACEMENT_UNDERPRICED`\r\n        | `${ Brand }.ERR_TRANSACTION_REPLACED`\r\n        | `${ Brand }.ERR_UNCONFIGURED_NAME`\r\n        | `${ Brand }.ERR_OFFCHAIN_FAULT`\r\n\r\n        /// User Interaction\r\n        | `${ Brand }.ERR_ACTION_REJECTED`;\r\n\r\n    export type Brand = \"ETHEREUM_VIRTUAL_MACHINE\";\r\n\r\n    export type TransactionResponse = _TransactionResponse$0;\r\n\r\n    export type TransactionReceipt = _TransactionReceipt$0;\r\n\r\n    export type Transaction<T1 = unknown, T2 extends Payload<T1> = Payload<T1>> =\r\n        | Query<T1, T2>\r\n        | Touch<T1, T2>\r\n        | Deployment<T1, T2>;\r\n\r\n    export type Query<T1 = unknown, T2 extends Payload<T1> = Payload<T1>> = {\r\n        privateKey: string;\r\n        to: Address;\r\n        signature: NonAmbientSignature;\r\n        payload?: T2;\r\n    };\r\n\r\n    export type Touch<T1 = unknown, T2 extends Payload<T1> = Payload<T1>> = {\r\n        privateKey: string;\r\n        to: Address;\r\n        signature: NonAmbientSignature;\r\n        payload?: T2;\r\n        gasPrice?: Fpv.Compatible<18n>;\r\n        gasLimit?: Fpv.Compatible<18n>;\r\n        amount?: Fpv.Compatible<18n>;\r\n        chainId?: bigint;\r\n        timeout?: bigint;\r\n        confirmations?: bigint;\r\n    };\r\n    \r\n    export type Deployment<T1 = unknown, T2 extends Payload<T1> = Payload<T1>> = {\r\n        privateKey: string;\r\n        bytecode: Bytecode;\r\n        abi: AbstractBinaryInterface;\r\n        payload?: T2;\r\n        gasPrice?: Fpv.Compatible<18n>;\r\n        gasLimit?: Fpv.Compatible<18n>;\r\n        amount?: Fpv.Compatible<18n>;\r\n        chainId?: bigint;\r\n        confirmations?: bigint;\r\n    };\r\n\r\n    export type Payload<T1 = unknown> = Array<T1>;\r\n\r\n    export type NonAmbientSignature = Exclude<Signature, EventSignature>;\r\n\r\n    export type Signature =\r\n        | EventSignature\r\n        | ExternalPureSignature\r\n        | ExternalViewSignature\r\n        | ExternalSignature;\r\n\r\n    export type SignatureHandler = {\r\n        nameOf(signature: Signature): Option<string>;\r\n    };\r\n\r\n    export const Signature: SignatureHandler = (() => {\r\n        /***/ {\r\n            return { nameOf };\r\n        }\r\n    \r\n        function nameOf(signature: Signature): Option<string> {\r\n            let shards: Array<string> = signature.split(\" \");\r\n            if (shards.length === 0) return None;\r\n            let string: Option<string> = flag(shards.at(1));\r\n            if (string.none()) return string;\r\n            let string$0: string = string.unwrap();\r\n            let result: Option<string> = flag(\r\n                string$0\r\n                    .split(\"(\")\r\n                    .at(0)\r\n            );\r\n            if (result.none()) return result;\r\n            let result$0: string = result.unwrap();\r\n            return Some(result$0);\r\n        }\r\n    })();\r\n\r\n    export type SignatureBuilder = {\r\n        name(name: string): SignatureBuilder;\r\n        event(): SignatureBuilder;\r\n        external(): SignatureBuilder;\r\n        pure(): SignatureBuilder;\r\n        view(): SignatureBuilder;\r\n        payload(...data: Array<Data>): SignatureBuilder;\r\n        returns(...data: Array<Data>): SignatureBuilder;\r\n        build(): SignatureBuilder.Result<Signature>;\r\n    };\r\n\r\n    export function SignatureBuilder(): SignatureBuilder {\r\n        let _this: SignatureBuilder;\r\n        let _name: Option<string>;\r\n        let _type: Option<\"event\" | \"external\">;\r\n        let _visibility: Option<\"pure\" | \"view\">;\r\n        let _payload: Option<Array<Data>>;\r\n        let _returns: Option<Array<Data>>;\r\n        \r\n        /***/ {\r\n            _this = {\r\n                name,\r\n                event,\r\n                external,\r\n                pure,\r\n                view,\r\n                payload,\r\n                returns,\r\n                build\r\n            };\r\n            _name = None;\r\n            _type = None;\r\n            _visibility = None;\r\n            _payload = None;\r\n            _returns = None;\r\n            return _this;\r\n        }\r\n    \r\n        function name(name: string): SignatureBuilder {\r\n            _name = Some(name);\r\n            return _this;\r\n        }\r\n    \r\n        function event(): SignatureBuilder {\r\n            _type = Some<\"event\">(\"event\");\r\n            return _this;\r\n        }\r\n    \r\n        function external(): SignatureBuilder {\r\n            _type = Some<\"external\">(\"external\");\r\n            return _this;\r\n        }\r\n    \r\n        function pure(): SignatureBuilder {\r\n            _visibility = Some<\"pure\">(\"pure\");\r\n            return _this;\r\n        }\r\n    \r\n        function view(): SignatureBuilder {\r\n            _visibility = Some<\"view\">(\"view\");\r\n            return _this;\r\n        }\r\n    \r\n        function payload(...data: Array<Data>): SignatureBuilder {\r\n            _payload = Some(data);\r\n            return _this;\r\n        }\r\n    \r\n        function returns(...data: Array<Data>): SignatureBuilder {\r\n            _returns = Some(data);\r\n            return _this;\r\n        }\r\n    \r\n        function build(): SignatureBuilder.Result<Signature> {\r\n            if (_name.none()) return Err(\"SIGNATURE_BUILDER.ERR_MISSING_NAME\");\r\n            let name: string = _name.unwrap();\r\n            if (_type.none()) return Err(\"SIGNATURE_BUILDER.ERR_MISSING_TYPE\");\r\n            let type: \"event\" | \"external\" = _type.unwrap();\r\n            if (type === \"event\") {\r\n                let selector: Selector = Selector.from(name, ..._payload.unwrapOr([]));\r\n                let signature: EventSignature = EventSignature.from(selector);\r\n                return Ok(signature);\r\n            }\r\n            if (type === \"external\") {\r\n                let selector: Selector = Selector.from(name, ..._payload.unwrapOr([]));\r\n                if (_visibility.none()) {\r\n                    let signature: ExternalSignature = ExternalSignature.from(selector);\r\n                    return Ok(signature);\r\n                }\r\n                let visibility: \"pure\" | \"view\" = _visibility.unwrap();\r\n                if (visibility === \"pure\") {\r\n                    let signature: ExternalPureSignature = ExternalPureSignature.from(selector, ..._returns.unwrapOr([]));\r\n                    return Ok(signature);\r\n                }\r\n                if (visibility === \"view\") {\r\n                    let signature: ExternalViewSignature = ExternalViewSignature.from(selector, ..._returns.unwrapOr([]));\r\n                    return Ok(signature);\r\n                }\r\n            }\r\n            return Err(\"SIGNATURE_BUILDER.ERR_MALFORMED_SIGNATURE\");\r\n        }\r\n    }\r\n    \r\n    export namespace SignatureBuilder {\r\n        export type Result<T1> = _Result$0<T1, ErrorCode>;\r\n    \r\n        export type ErrorCode =\r\n            | \"SIGNATURE_BUILDER.ERR_MISSING_NAME\"\r\n            | \"SIGNATURE_BUILDER.ERR_MISSING_TYPE\"\r\n            | \"SIGNATURE_BUILDER.ERR_MALFORMED_SIGNATURE\";\r\n    }\r\n\r\n    export type ExternalSignature = `function ${ string }(${ string }) external`;\r\n\r\n    export type ExternalSignatureHandler = {\r\n        from(selector: Selector): ExternalSignature;\r\n    };\r\n\r\n    export const ExternalSignature: ExternalSignatureHandler = (() => {\r\n        /***/ {\r\n            return { from };\r\n        }\r\n    \r\n        function from(selector: Selector): ExternalSignature {\r\n            return `function ${ selector } external`;\r\n        }\r\n    })();\r\n\r\n    export type ExternalViewSignature = `function ${ string }(${ string }) external view returns (${ string })`;\r\n\r\n    export type ExternalViewSignatureHandler = {\r\n        from(selector: Selector, ...data: Array<Data>): ExternalViewSignature;\r\n    };\r\n\r\n    export const ExternalViewSignature: ExternalViewSignatureHandler = (() => {\r\n        /***/ {\r\n            return { from };\r\n        }\r\n    \r\n        function from(selector: Selector, ...data: Array<Data>): ExternalViewSignature {\r\n            return `function ${ selector } external view returns (${ Data.serialize(...data) })`;\r\n        }\r\n    })();\r\n\r\n    export type ExternalPureSignature = `function ${ string }(${ string }) external pure returns (${ string })`;\r\n\r\n    export type ExternalPureSignatureHandler = {\r\n        from(selector: Selector, ...data: Array<Data>): ExternalPureSignature;\r\n    };\r\n\r\n    export const ExternalPureSignature: ExternalPureSignatureHandler = (() => {\r\n        /** @constructor */ {\r\n            return { from };\r\n        }\r\n    \r\n        function from(selector: Selector, ...data: Array<Data>): ExternalPureSignature {\r\n            return `function ${ selector } external pure returns (${ Data.serialize(...data) })`;\r\n        }\r\n    })();\r\n\r\n    export type EventSignature = `event ${ string }(${ string })`;\r\n\r\n    export type EventSignatureHandler = {\r\n        from(selector: Selector): EventSignature;\r\n    };\r\n\r\n    export const EventSignature: EventSignatureHandler = (() => {\r\n        /** @constructor */ {\r\n            return { from };\r\n        }\r\n    \r\n        function from(selector: Selector): EventSignature {\r\n            return `event ${ selector }`;\r\n        }\r\n    })();\r\n\r\n    export type Selector = `${ string }(${ string })`;\r\n\r\n    export type SelectorHandler = {\r\n        from(name: string, ...data: Array<Data>): Selector; \r\n    };\r\n\r\n    export const Selector: SelectorHandler = (() => {\r\n        /** @constructor */ {\r\n            return { from };\r\n        }\r\n        \r\n        function from(name: string, ...data: Array<Data>): Selector {\r\n            return `${ name }(${ Data.serialize(...data) })`;\r\n        }\r\n    })();\r\n\r\n    export type ArrayData = `${ \r\n        | ArithmeticData \r\n        | BytesData \r\n        | AddressData \r\n        | BooleanData \r\n        | StringData }[]`;\r\n\r\n    export type Data =\r\n        | ArithmeticData\r\n        | BytesData\r\n        | AddressData\r\n        | BooleanData\r\n        | StringData\r\n        | ArrayData\r\n        | StructData;\r\n\r\n    export type DataHandler = {\r\n        serialize(...data: Array<Data>): string;\r\n    };\r\n\r\n    export const Data: DataHandler = (() => {\r\n        /** @constructor */ {\r\n            return { serialize };\r\n        }\r\n\r\n        function serialize(...data: Array<Data>): string {\r\n            let result: string = \"\";\r\n            for (let i: bigint = 0n; i < data.length; i ++) {\r\n                if (i !== 0n) result = \", \";\r\n                result += data[Number(i)];\r\n            }\r\n            return result;\r\n        }\r\n    })();\r\n\r\n    export type StructData = Array<Data>;\r\n\r\n    export type BooleanData = \"bool\";\r\n\r\n    export type AddressData = \"address\";\r\n\r\n    export type StringData = \"string\";\r\n\r\n    export type BytesData = \"bytes\" | `bytes${ BytesDataBitSize }`;\r\n\r\n    export type BytesDataBitSize = \r\n        | \"1\" | \"2\" | \"3\" \r\n        | \"4\" | \"5\" | \"6\" \r\n        | \"7\" | \"8\" | \"9\" \r\n        | \"10\" | \"11\" | \"12\" \r\n        | \"13\" | \"14\" | \"15\" \r\n        | \"16\" | \"17\" | \"18\" \r\n        | \"19\" | \"20\" | \"21\" \r\n        | \"22\" | \"23\" | \"24\" \r\n        | \"25\" | \"26\" | \"27\" \r\n        | \"28\" | \"29\" | \"30\" \r\n        | \"31\" | \"32\";\r\n\r\n    export type ArithmeticData = \"uint\" | \"int\" | `${ \"uint\" | \"int\" }${ ArithmeticDataBitSize }`;\r\n\r\n    export type ArithmeticDataBitSize = \r\n        | \"8\" \r\n        | \"16\" | \"24\" | \"32\" \r\n        | \"40\" | \"48\" | \"56\" \r\n        | \"64\" | \"72\" | \"80\" \r\n        | \"88\" | \"96\" \r\n        | \"104\" | \"112\" | \"120\" \r\n        | \"128\" | \"136\" | \"144\" \r\n        | \"152\" | \"160\" | \"168\" \r\n        | \"176\" | \"184\" | \"192\" \r\n        | \"200\" | \"208\" | \"216\" \r\n        | \"224\" | \"232\" | \"240\" \r\n        | \"248\" | \"256\";\r\n\r\n    export type AbstractBinaryInterface = Array<Signature> | Array<object>;\r\n\r\n    export type Bytecode = string;\r\n\r\n    export type Address = `0x${ string }`;\r\n}"],"mappings":"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","names":["e","EthereumVirtualMachine","name"]}