{"version":3,"sources":["../../../src/web/wallet.ts"],"sourcesContent":["import { \r\n    Unsafe,\r\n    Option,\r\n    Result,\r\n    Some,\r\n    None,\r\n    Ok,\r\n    Err,\r\n    Fpv,\r\n    flag,\r\n    wrap,\r\n    wrapAsync\r\n} from \"@tokyo/reliq\";\r\nimport { \r\n    type BaseContract,\r\n    type ContractMethod,\r\n    type TransactionResponse,\r\n    type TransactionReceipt,\r\n    Contract,\r\n    ContractFactory,\r\n    Interface,\r\n    BrowserProvider,\r\n    JsonRpcSigner\r\n} from \"ethers\";\r\n\r\ntype _Result$0<T1, T2> = Result<T1, T2>;\r\n\r\ntype _TransactionResponse$0 = TransactionResponse;\r\n\r\ntype _TransactionReceipt$0 = TransactionReceipt;\r\n\r\nexport type Wallet = {\r\n    use(account: Wallet.Address): Promise<Wallet.Result<Wallet>>;\r\n    use(account: bigint): Promise<Wallet.Result<Wallet>>;\r\n    use(account: Wallet.Address | bigint): Promise<Wallet.Result<Wallet>>;\r\n    connected(): boolean;\r\n    connected(address: Wallet.Address): Promise<Wallet.Result<boolean>>;\r\n    connected(address?: Wallet.Address):\r\n        | Promise<Wallet.Result<boolean>>\r\n        | boolean;\r\n    address(): Promise<Wallet.Result<Wallet.Address>>;\r\n    nonce(): Promise<Wallet.Result<bigint>>;\r\n    query<T1 = unknown, T2 extends Wallet.Payload<T1> = Wallet.Payload<T1>>(transaction: Wallet.Query<T1, T2>): Promise<Wallet.Result<Unsafe>>;\r\n    touch<T1 = unknown, T2 extends Wallet.Payload<T1> = Wallet.Payload<T1>>(transaction: Wallet.Touch<T1, T2>): Promise<Wallet.Result<Option<Wallet.TransactionReceipt>>>;\r\n    deploy<T1 = unknown, T2 extends Wallet.Payload<T1> = Wallet.Payload<T1>>(transaction: Wallet.Deployment<T1, T2>): Promise<Wallet.Result<Wallet.Address>>;\r\n}\r\n\r\nexport async function Wallet(): Promise<Wallet.Result<Wallet>> {\r\n    let _this: Wallet;\r\n    let _socket: BrowserProvider;\r\n    let _accounts: Array<string>;\r\n    let _signer: Option<JsonRpcSigner> = None;\r\n\r\n    /***/ {\r\n        return (await _connect()).map(([socket, accounts]) => {\r\n            _socket = socket;\r\n            _accounts = accounts;\r\n            return _this = {\r\n                use,\r\n                connected,\r\n                address,\r\n                nonce,\r\n                query,\r\n                touch,\r\n                deploy\r\n            };\r\n        });\r\n    }\r\n\r\n    async function use(account: Wallet.Address): Promise<Wallet.Result<Wallet>>;\r\n    async function use(account: bigint): Promise<Wallet.Result<Wallet>>;\r\n    async function use(account: Wallet.Address | bigint): Promise<Wallet.Result<Wallet>> {\r\n        let signer: Wallet.Result<JsonRpcSigner> = (await _map(wrapAsync(async () => {\r\n            return (await _socket.getSigner(typeof account === \"string\" ? account : Number(account)));\r\n        })));\r\n        if (signer.err()) return signer;\r\n        return Ok(_this);\r\n    }\r\n\r\n    function connected(): boolean;\r\n    function connected(address: Wallet.Address): Promise<Wallet.Result<boolean>>;\r\n    function connected(address?: Wallet.Address): \r\n        | Promise<Wallet.Result<boolean>> \r\n        | boolean {\r\n        if (address && _signer.some()) {\r\n            return new Promise(resolve => {\r\n                let signer: JsonRpcSigner = _signer.unwrap();\r\n                _map(wrapAsync(async () => {\r\n                    return await signer.getAddress();\r\n                }))\r\n                .then(address$0 => {\r\n                    if (address$0.ok()) {\r\n                        let address$1: string = address$0.unwrap();\r\n                        resolve(Ok(address$1 === address));\r\n                        return; \r\n                    }\r\n                    return address$0;\r\n                });\r\n            });\r\n        }\r\n        return _signer.some();\r\n    }\r\n\r\n    async function address(): Promise<Wallet.Result<Wallet.Address>> {\r\n        return (await _map(wrapAsync(async () => {\r\n            return (await (await _socket.getSigner()).getAddress()) as Wallet.Address;\r\n        })));\r\n    }\r\n\r\n    async function nonce(): Promise<Wallet.Result<bigint>> {\r\n        return (await _map((wrapAsync(async () => {\r\n            return (await _socket.getSigner()).getNonce();\r\n        }))))\r\n        .map(nonce => {\r\n            return BigInt(nonce);\r\n        });\r\n    }\r\n\r\n    async function query<T1 = unknown, T2 extends Wallet.Payload<T1> = Wallet.Payload<T1>>(transaction: Wallet.Query<T1, T2>): Promise<Wallet.Result<Unsafe>> {\r\n        let signer: JsonRpcSigner;\r\n        if (_signer.none()) {\r\n            let signer$0: Wallet.Result<JsonRpcSigner> = await _map(wrapAsync(async () => {\r\n                return await _socket.getSigner();\r\n            }));\r\n            if (signer$0.err()) return signer$0;\r\n            let signer$1: JsonRpcSigner = signer$0.unwrap();\r\n            signer = signer$1;\r\n        }\r\n        else {\r\n            signer = _signer.unwrap();\r\n        }\r\n        let contract: Wallet.Result<Contract> = _map(wrap(() => {\r\n            return new Contract(transaction.to, [transaction.signature], signer);\r\n        }));\r\n        if (contract.err()) return contract;\r\n        let contract$0: Contract = contract.unwrap();\r\n        let contractMethod: Wallet.Result<ContractMethod> = _map(wrap(() => {\r\n            return contract$0.getFunction(transaction.signature);\r\n        }));\r\n        if (contractMethod.err()) return contractMethod;\r\n        let contractMethod$0: ContractMethod = contractMethod.unwrap();\r\n        let response: Wallet.Result<Unsafe> = await _map(wrapAsync(async () => {\r\n            return Unsafe(await contractMethod$0(...transaction.payload ?? []));\r\n        }));\r\n        if (response.err()) return response;\r\n        let response$0: Unsafe = response.unwrap();\r\n        return Ok(response$0);\r\n    }\r\n\r\n    async function touch<T1 = unknown, T2 extends Wallet.Payload<T1> = Wallet.Payload<T1>>(transaction: Wallet.Touch<T1, T2>): Promise<Wallet.Result<Option<Wallet.TransactionReceipt>>> {\r\n        let signer: JsonRpcSigner;\r\n        if (_signer.none()) {\r\n            let signer$0: Wallet.Result<JsonRpcSigner> = await _map(wrapAsync(async () => {\r\n                return await _socket.getSigner();\r\n            }));\r\n            if (signer$0.err()) return signer$0;\r\n            let signer$1: JsonRpcSigner = signer$0.unwrap();\r\n            signer = signer$1;\r\n        }\r\n        else {\r\n            signer = _signer.unwrap();\r\n        }\r\n        let address$0: Wallet.Result<Wallet.Address> = (await address());\r\n        if (address$0.err()) return address$0;\r\n        let address$1: Wallet.Address = address$0.unwrap();\r\n        let nonce$0: Wallet.Result<bigint> = (await nonce());\r\n        if (nonce$0.err()) return nonce$0;\r\n        let nonce$1: bigint = nonce$0.unwrap();\r\n        let interface$0: Wallet.Result<Interface> = _map(wrap(() => {\r\n            return new Interface([transaction.signature]);\r\n        }));\r\n        if (interface$0.err()) return interface$0;\r\n        let interface$1: Interface = interface$0.unwrap();\r\n        let name: Option<string> = Wallet.Signature.nameOf(transaction.signature);\r\n        if (name.none()) return Err({\r\n            code: \"WALLET.ERR_MALFORMED_SIGNATURE\",\r\n            data: None,\r\n            message: None,\r\n            reason: None,\r\n            transaction: None\r\n        });\r\n        let name$0: string = name.unwrap();\r\n        let data: Wallet.Result<string> = _map(wrap(() => {\r\n            return interface$1.encodeFunctionData(name$0, transaction.payload);\r\n        }));\r\n        if (data.err()) return data;\r\n        let data$0: string = data.unwrap();\r\n        let gasPrice: bigint = transaction.gasPrice ? Fpv.Calculator.unwrap(transaction.gasPrice) : 0n;\r\n        let gasLimit: bigint = transaction.gasLimit ? Fpv.Calculator.unwrap(transaction.gasLimit) : 0n;\r\n        let response: Wallet.Result<Wallet.TransactionResponse | null> = (await _map(wrapAsync(async () => {\r\n            return await signer.sendTransaction({\r\n                from: address$1,\r\n                to: transaction.to,\r\n                nonce: Number(nonce$1),\r\n                gasPrice: gasPrice,\r\n                gasLimit: gasLimit,\r\n                data: data$0\r\n            });\r\n        })));\r\n        if (response.err()) return response;\r\n        let response$0: Wallet.TransactionResponse | null = response.unwrap();\r\n        if (response$0 === null) return Err({\r\n            code: \"WALLET.ERR_INVALID_RESPONSE\",\r\n            data: None,\r\n            message: None,\r\n            transaction: None,\r\n            reason: None\r\n        });\r\n        let receipt: Wallet.Result<Wallet.TransactionReceipt | null> = (await _map(wrapAsync(async () => {\r\n            return await response$0.wait(Number(transaction.confirmations), Number(transaction.timeout));\r\n        })));\r\n        if (receipt.err()) return receipt;\r\n        let receipt$0: Wallet.TransactionReceipt | null = receipt.unwrap();\r\n        if (receipt$0 === null) return Ok(None);\r\n        return Ok(Some(receipt$0));\r\n    }\r\n\r\n    async function deploy<T1 = unknown, T2 extends Wallet.Payload<T1> = Wallet.Payload<T1>>(transaction: Wallet.Deployment<T1, T2>): Promise<Wallet.Result<Wallet.Address>> {\r\n        let signer: JsonRpcSigner;\r\n        if (_signer.none()) {\r\n            let signer$0: Wallet.Result<JsonRpcSigner> = await _map(wrapAsync(async () => {\r\n                return await _socket.getSigner();\r\n            }));\r\n            if (signer$0.err()) return signer$0;\r\n            let signer$1: JsonRpcSigner = signer$0.unwrap();\r\n            signer = signer$1;\r\n        }\r\n        else {\r\n            signer = _signer.unwrap();\r\n        }\r\n        let contractFactory: Wallet.Result<ContractFactory> = _map(wrap(() => {\r\n            return new ContractFactory(transaction.abi, transaction.bytecode, signer);\r\n        }));\r\n        if (contractFactory.err()) return contractFactory;\r\n        let contractFactory$0: ContractFactory = contractFactory.unwrap();\r\n        let contract: Wallet.Result<BaseContract> = (await _map(wrapAsync(async () => {\r\n            return (await contractFactory$0.deploy(transaction.payload));\r\n        })));\r\n        if (contract.err()) return contract;\r\n        let contract$0: BaseContract = contract.unwrap();\r\n        let address: Wallet.Result<Wallet.Address> = (await _map(wrapAsync(async () => {\r\n            return await contract$0.getAddress() as Wallet.Address;\r\n        })));\r\n        if (address.err()) return address;\r\n        let address$0: Wallet.Address = address.unwrap();\r\n        return Ok(address$0);\r\n    }\r\n\r\n    async function _connect(): Promise<Wallet.Result<[BrowserProvider, Array<string>]>> {\r\n        if (window === undefined) return Err({\r\n            code: \"WALLET.ERR_UNSUPPORTED_OPERATION\",\r\n            data: None,\r\n            message: Some(\"Wallet: ...\"),\r\n            reason: None,\r\n            transaction: None\r\n        });\r\n        if ((\"ethereum\" in window) === false) return Err({\r\n            code: \"WALLET.ERR_UNSUPPORTED_OPERATION\",\r\n            data: None,\r\n            message: Some(\"Wallet: ...\"),\r\n            reason: None,\r\n            transaction: None\r\n        });\r\n        let socket: Wallet.Result<BrowserProvider> = _map(wrap(() => {\r\n            return new BrowserProvider((window as any).ethereum);\r\n        }));\r\n        if (socket.err()) return socket;\r\n        let socket$0: BrowserProvider = socket.unwrap();\r\n        let accounts: Wallet.Result<Array<string>> = await _map(wrapAsync(async () => {\r\n            return socket$0.send(\"eth_accounts\", []);\r\n        }));\r\n        if (accounts.err()) return accounts;\r\n        let accounts$0: Array<string> = accounts.unwrap();\r\n        if (accounts$0.length > 0) return Ok<[BrowserProvider, Array<string>]>([socket$0, accounts$0]);\r\n        let accounts$1: Wallet.Result<Array<string>> = await _map(wrapAsync(async () => {\r\n            return socket$0.send(\"eth_requestAccounts\", []);\r\n        }));\r\n        if (accounts$1.err()) return accounts$1;\r\n        let accounts$2: Array<string> = accounts$1.unwrap();\r\n        if (accounts$2.length > 0) return Ok<[BrowserProvider, Array<string>]>([socket$0, accounts$2]);\r\n        return Err({\r\n            code: \"WALLET.ERR_UNCONFIGURED_NAME\",\r\n            data: None,\r\n            message: None,\r\n            reason: None,\r\n            transaction: None\r\n        });\r\n    }\r\n\r\n    function _map<T1>(result: Promise<_Result$0<T1, Unsafe>>): Promise<Wallet.Result<T1>>;\r\n    function _map<T1>(result: _Result$0<T1, Unsafe>): Wallet.Result<T1>;\r\n    function _map<T1>(unsafe: Unsafe): Wallet.Error;\r\n    function _map<T1>(\r\n        p0:\r\n            | Promise<_Result$0<T1, Unsafe>>\r\n            | _Result$0<T1, Unsafe>\r\n            | Unsafe\r\n    ):\r\n        | Promise<Wallet.Result<T1>>\r\n        | Wallet.Result<T1>\r\n        | Wallet.Error {\r\n        if (\"then\" in p0) {\r\n            let result: Promise<_Result$0<T1, Unsafe>> = p0;\r\n            return result.then(result$0 => {\r\n                return _map(result$0);\r\n            });\r\n        }\r\n        if (\"ok\" in p0) {\r\n            let result: _Result$0<T1, Unsafe> = p0;\r\n            return result.mapErr(e => {\r\n                return _map(e);\r\n            });\r\n        }\r\n        let unsafe: Unsafe = p0;\r\n        let e: unknown = unsafe.inspect();\r\n        if (!(\r\n            e !== null\r\n            && e !== undefined\r\n            && typeof e == \"object\"\r\n            && \"code\" in e\r\n            && typeof e.code === \"string\"\r\n        )) return {\r\n            code: \"WALLET.ERR_UNKNOWN\",\r\n            data: None,\r\n            message: None,\r\n            reason: None,\r\n            transaction: None\r\n        };\r\n        let map: Record<string, Wallet.ErrorCode | undefined> = {\r\n            \"UNKNOWN_ERROR\": \"WALLET.ERR_UNKNOWN\",\r\n            \"NOT_IMPLEMENTED\": \"WALLET.ERR_NOT_IMPLEMENTED\",\r\n            \"UNSUPPORTED_OPERATION\": \"WALLET.ERR_UNSUPPORTED_OPERATION\",\r\n            \"NETWORK_ERROR\": \"WALLET.ERR_NETWORK_FAULT\",\r\n            \"SERVER_ERROR\": \"WALLET.ERR_SERVER_FAULT\",\r\n            \"TIMEOUT\": \"WALLET.ERR_TIMEOUT\",\r\n            \"BAD_DATA\": \"WALLET.ERR_BAD_DATA\",\r\n            \"CANCELLED\": \"WALLET.ERR_CANCELLED\",\r\n            \"BUFFEER_OVERRUN\": \"WALLET.ERR_BUFFER_OVERRUN\",\r\n            \"NUMERIC_FAULT\": \"WALLET.ERR_NUMERIC_FAULT\",\r\n            \"INVALID_ARGUMENT\": \"WALLET.ERR_INVALID_ARGUMENT\",\r\n            \"INVALID_RESPONSE\": \"WALLET.ERR_INVALID_RESPONSE\",\r\n            \"MISSSING_ARGUMENT\": \"WALLET.ERR_MISSING_ARGUMENT\",\r\n            \"UNEXPECTED_ARGUMENT\": \"WALLET.ERR_UNEXPECTED_ARGUMENT\",\r\n            \"CALL_EXCEPTION\": \"WALLET.ERR_CALL_EXCEPTION\",\r\n            \"INSUFFICIEENT_FUNDS\": \"WALLET.ERR_INSUFFICIENT_FUNDS\",\r\n            \"NONCE_EXPIRED\": \"WALLET.ERR_NONCE_EXPIRED\",\r\n            \"REPLACEMENT_UNDERPRICED\": \"WALLET.ERR_REPLACEMENT_UNDERPRICED\",\r\n            \"TRANSACTION_REPLACED\": \"WALLET.ERR_TRANSACTION_REPLACED\",\r\n            \"UNCONFIGURED_NAME\": \"WALLET.ERR_UNCONFIGURED_NAME\",\r\n            \"OFFCHAIN_FAULT\": \"WALLET.ERR_OFFCHAIN_FAULT\",\r\n            \"ACTION_REJECTED\": \"WALLET.ERR_ACTION_REJECTED\"\r\n        };\r\n        let code: Wallet.ErrorCode = map[e.code] ?? \"WALLET.ERR_UNKNOWN\";\r\n        let data: Option<unknown> = None;\r\n        let message: Option<unknown> = None;\r\n        let transaction: Option<unknown> = None;\r\n        let reason: Option<unknown> = None;\r\n        if (\"data\" in e) data = Some(e.data);\r\n        if (\"message\" in e) data = Some(e.message);\r\n        if (\"transaction\" in e) data = Some(e.transaction);\r\n        if (\"reason\" in e) data = Some(e.reason);\r\n        return { code, data, message, transaction, reason };\r\n    }\r\n}\r\n\r\nexport namespace Wallet {\r\n    export type Result<T1> = _Result$0<T1, Error>;\r\n\r\n    export type Error = {\r\n        code: ErrorCode;\r\n        data: Option<unknown>;\r\n        message: Option<unknown>;\r\n        transaction: Option<unknown>;\r\n        reason: Option<unknown>;\r\n    };\r\n\r\n    export type ErrorCode =\r\n        | `${ Brand }.ERR_MALFORMED_SIGNATURE`\r\n\r\n        /// Generic\r\n        | `${ Brand }.ERR_UNKNOWN`\r\n        | `${ Brand }.ERR_NOT_IMPLEMENTED`\r\n        | `${ Brand }.ERR_UNSUPPORTED_OPERATION`\r\n        | `${ Brand }.ERR_NETWORK_FAULT`\r\n        | `${ Brand }.ERR_SERVER_FAULT`\r\n        | `${ Brand }.ERR_TIMEOUT`\r\n        | `${ Brand }.ERR_BAD_DATA`\r\n        | `${ Brand }.ERR_CANCELLED`\r\n        | `${ Brand }.ERR_INVALID_RESPONSE`\r\n\r\n        /// Operational\r\n        | `${ Brand }.ERR_BUFFER_OVERRUN`\r\n        | `${ Brand }.ERR_NUMERIC_FAULT`\r\n\r\n        /// Argument\r\n        | `${ Brand }.ERR_INVALID_ARGUMENT`\r\n        | `${ Brand }.ERR_MISSING_ARGUMENT`\r\n        | `${ Brand }.ERR_UNEXPECTED_ARGUMENT`\r\n\r\n        /// Blockchain\r\n        | `${ Brand }.ERR_CALL_EXCEPTION`\r\n        | `${ Brand }.ERR_INSUFFICIENT_FUNDS`\r\n        | `${ Brand }.ERR_NONCE_EXPIRED`\r\n        | `${ Brand }.ERR_REPLACEMENT_UNDERPRICED`\r\n        | `${ Brand }.ERR_TRANSACTION_REPLACED`\r\n        | `${ Brand }.ERR_UNCONFIGURED_NAME`\r\n        | `${ Brand }.ERR_OFFCHAIN_FAULT`\r\n\r\n        /// User Interaction\r\n        | `${ Brand }.ERR_ACTION_REJECTED`;\r\n\r\n    export type Brand = \"WALLET\";\r\n\r\n    export type TransactionResponse = _TransactionResponse$0;\r\n\r\n    export type TransactionReceipt = _TransactionReceipt$0;\r\n\r\n    export type Transaction<T1 = unknown, T2 extends Payload<T1> = Payload<T1>> =\r\n        | Query<T1, T2>\r\n        | Touch<T1, T2>\r\n        | Deployment<T1, T2>;\r\n\r\n    export type Query<T1 = unknown, T2 extends Payload<T1> = Payload<T1>> = {\r\n        to: Address;\r\n        signature: NonAmbientSignature;\r\n        payload?: T2;\r\n    };\r\n\r\n    export type Touch<T1 = unknown, T2 extends Payload<T1> = Payload<T1>> = {\r\n        to: Address;\r\n        signature: NonAmbientSignature;\r\n        payload?: T2;\r\n        gasPrice?: Fpv.Compatible<18n>;\r\n        gasLimit?: Fpv.Compatible<18n>;\r\n        amount?: Fpv.Compatible<18n>;\r\n        chainId?: bigint;\r\n        timeout?: bigint;\r\n        confirmations?: bigint;\r\n    };\r\n\r\n    export type Deployment<T1 = unknown, T2 extends Payload<T1> = Payload<T1>> = {\r\n        bytecode: Bytecode;\r\n        abi: AbstractBinaryInterface;\r\n        payload?: T2;\r\n        gasPrice?: Fpv.Compatible<18n>;\r\n        gasLimit?: Fpv.Compatible<18n>;\r\n        amount?: Fpv.Compatible<18n>;\r\n        chainId?: bigint;\r\n        confirmations?: bigint;\r\n    };\r\n\r\n    export type Payload<T1 = unknown> = Array<T1>;\r\n\r\n    export type NonAmbientSignature = Exclude<Signature, EventSignature>;\r\n\r\n    export type Signature =\r\n        | EventSignature\r\n        | ExternalPureSignature\r\n        | ExternalViewSignature\r\n        | ExternalSignature;\r\n\r\n    export type SignatureHandler = {\r\n        nameOf(signature: Signature): Option<string>;\r\n    };\r\n\r\n    export const Signature: SignatureHandler = (() => {\r\n        /***/ {\r\n            return { nameOf };\r\n        }\r\n    \r\n        function nameOf(signature: Signature): Option<string> {\r\n            let shards: Array<string> = signature.split(\" \");\r\n            if (shards.length === 0) return None;\r\n            let string: Option<string> = flag(shards.at(1));\r\n            if (string.none()) return string;\r\n            let string$0: string = string.unwrap();\r\n            let result: Option<string> = flag(\r\n                string$0\r\n                    .split(\"(\")\r\n                    .at(0)\r\n            );\r\n            if (result.none()) return result;\r\n            let result$0: string = result.unwrap();\r\n            return Some(result$0);\r\n        }\r\n    })();\r\n\r\n    export type SignatureBuilder = {\r\n        name(name: string): SignatureBuilder;\r\n        event(): SignatureBuilder;\r\n        external(): SignatureBuilder;\r\n        pure(): SignatureBuilder;\r\n        view(): SignatureBuilder;\r\n        payload(...data: Array<Data>): SignatureBuilder;\r\n        returns(...data: Array<Data>): SignatureBuilder;\r\n        build(): SignatureBuilder.Result<Signature>;\r\n    };\r\n\r\n    export function SignatureBuilder(): SignatureBuilder {\r\n        let _this: SignatureBuilder;\r\n        let _name: Option<string>;\r\n        let _type: Option<\"event\" | \"external\">;\r\n        let _visibility: Option<\"pure\" | \"view\">;\r\n        let _payload: Option<Array<Data>>;\r\n        let _returns: Option<Array<Data>>;\r\n        \r\n        /***/ {\r\n            _this = {\r\n                name,\r\n                event,\r\n                external,\r\n                pure,\r\n                view,\r\n                payload,\r\n                returns,\r\n                build\r\n            };\r\n            _name = None;\r\n            _type = None;\r\n            _visibility = None;\r\n            _payload = None;\r\n            _returns = None;\r\n            return _this;\r\n        }\r\n    \r\n        function name(name: string): SignatureBuilder {\r\n            _name = Some(name);\r\n            return _this;\r\n        }\r\n    \r\n        function event(): SignatureBuilder {\r\n            _type = Some<\"event\">(\"event\");\r\n            return _this;\r\n        }\r\n    \r\n        function external(): SignatureBuilder {\r\n            _type = Some<\"external\">(\"external\");\r\n            return _this;\r\n        }\r\n    \r\n        function pure(): SignatureBuilder {\r\n            _visibility = Some<\"pure\">(\"pure\");\r\n            return _this;\r\n        }\r\n    \r\n        function view(): SignatureBuilder {\r\n            _visibility = Some<\"view\">(\"view\");\r\n            return _this;\r\n        }\r\n    \r\n        function payload(...data: Array<Data>): SignatureBuilder {\r\n            _payload = Some(data);\r\n            return _this;\r\n        }\r\n    \r\n        function returns(...data: Array<Data>): SignatureBuilder {\r\n            _returns = Some(data);\r\n            return _this;\r\n        }\r\n    \r\n        function build(): SignatureBuilder.Result<Signature> {\r\n            if (_name.none()) return Err(\"SIGNATURE_BUILDER.ERR_MISSING_NAME\");\r\n            let name: string = _name.unwrap();\r\n            if (_type.none()) return Err(\"SIGNATURE_BUILDER.ERR_MISSING_TYPE\");\r\n            let type: \"event\" | \"external\" = _type.unwrap();\r\n            if (type === \"event\") {\r\n                let selector: Selector = Selector.from(name, ..._payload.unwrapOr([]));\r\n                let signature: EventSignature = EventSignature.from(selector);\r\n                return Ok(signature);\r\n            }\r\n            if (type === \"external\") {\r\n                let selector: Selector = Selector.from(name, ..._payload.unwrapOr([]));\r\n                if (_visibility.none()) {\r\n                    let signature: ExternalSignature = ExternalSignature.from(selector);\r\n                    return Ok(signature);\r\n                }\r\n                let visibility: \"pure\" | \"view\" = _visibility.unwrap();\r\n                if (visibility === \"pure\") {\r\n                    let signature: ExternalPureSignature = ExternalPureSignature.from(selector, ..._returns.unwrapOr([]));\r\n                    return Ok(signature);\r\n                }\r\n                if (visibility === \"view\") {\r\n                    let signature: ExternalViewSignature = ExternalViewSignature.from(selector, ..._returns.unwrapOr([]));\r\n                    return Ok(signature);\r\n                }\r\n            }\r\n            return Err(\"SIGNATURE_BUILDER.ERR_MALFORMED_SIGNATURE\");\r\n        }\r\n    }\r\n    \r\n    export namespace SignatureBuilder {\r\n        export type Result<T1> = _Result$0<T1, ErrorCode>;\r\n    \r\n        export type ErrorCode =\r\n            | \"SIGNATURE_BUILDER.ERR_MISSING_NAME\"\r\n            | \"SIGNATURE_BUILDER.ERR_MISSING_TYPE\"\r\n            | \"SIGNATURE_BUILDER.ERR_MALFORMED_SIGNATURE\";\r\n    }\r\n\r\n    export type ExternalSignature = `function ${ string }(${ string }) external`;\r\n\r\n    export type ExternalSignatureHandler = {\r\n        from(selector: Selector): ExternalSignature;\r\n    };\r\n\r\n    export const ExternalSignature: ExternalSignatureHandler = (() => {\r\n        /***/ {\r\n            return { from };\r\n        }\r\n    \r\n        function from(selector: Selector): ExternalSignature {\r\n            return `function ${ selector } external`;\r\n        }\r\n    })();\r\n\r\n    export type ExternalViewSignature = `function ${ string }(${ string }) external view returns (${ string })`;\r\n\r\n    export type ExternalViewSignatureHandler = {\r\n        from(selector: Selector, ...data: Array<Data>): ExternalViewSignature;\r\n    };\r\n\r\n    export const ExternalViewSignature: ExternalViewSignatureHandler = (() => {\r\n        /***/ {\r\n            return { from };\r\n        }\r\n    \r\n        function from(selector: Selector, ...data: Array<Data>): ExternalViewSignature {\r\n            return `function ${ selector } external view returns (${ Data.serialize(...data) })`;\r\n        }\r\n    })();\r\n\r\n    export type ExternalPureSignature = `function ${ string }(${ string }) external pure returns (${ string })`;\r\n\r\n    export type ExternalPureSignatureHandler = {\r\n        from(selector: Selector, ...data: Array<Data>): ExternalPureSignature;\r\n    };\r\n\r\n    export const ExternalPureSignature: ExternalPureSignatureHandler = (() => {\r\n        /** @constructor */ {\r\n            return { from };\r\n        }\r\n    \r\n        function from(selector: Selector, ...data: Array<Data>): ExternalPureSignature {\r\n            return `function ${ selector } external pure returns (${ Data.serialize(...data) })`;\r\n        }\r\n    })();\r\n\r\n    export type EventSignature = `event ${ string }(${ string })`;\r\n\r\n    export type EventSignatureHandler = {\r\n        from(selector: Selector): EventSignature;\r\n    };\r\n\r\n    export const EventSignature: EventSignatureHandler = (() => {\r\n        /** @constructor */ {\r\n            return { from };\r\n        }\r\n    \r\n        function from(selector: Selector): EventSignature {\r\n            return `event ${ selector }`;\r\n        }\r\n    })();\r\n\r\n    export type Selector = `${ string }(${ string })`;\r\n\r\n    export type SelectorHandler = {\r\n        from(name: string, ...data: Array<Data>): Selector; \r\n    };\r\n\r\n    export const Selector: SelectorHandler = (() => {\r\n        /** @constructor */ {\r\n            return { from };\r\n        }\r\n        \r\n        function from(name: string, ...data: Array<Data>): Selector {\r\n            return `${ name }(${ Data.serialize(...data) })`;\r\n        }\r\n    })();\r\n\r\n    export type ArrayData = `${ \r\n        | ArithmeticData \r\n        | BytesData \r\n        | AddressData \r\n        | BooleanData \r\n        | StringData }[]`;\r\n\r\n    export type Data =\r\n        | ArithmeticData\r\n        | BytesData\r\n        | AddressData\r\n        | BooleanData\r\n        | StringData\r\n        | ArrayData\r\n        | StructData;\r\n\r\n    export type DataHandler = {\r\n        serialize(...data: Array<Data>): string;\r\n    };\r\n\r\n    export const Data: DataHandler = (() => {\r\n        /** @constructor */ {\r\n            return { serialize };\r\n        }\r\n\r\n        function serialize(...data: Array<Data>): string {\r\n            let result: string = \"\";\r\n            for (let i: bigint = 0n; i < data.length; i ++) {\r\n                if (i !== 0n) result = \", \";\r\n                result += data[Number(i)];\r\n            }\r\n            return result;\r\n        }\r\n    })();\r\n\r\n    export type StructData = Array<Data>;\r\n\r\n    export type BooleanData = \"bool\";\r\n\r\n    export type AddressData = \"address\";\r\n\r\n    export type StringData = \"string\";\r\n\r\n    export type BytesData = \"bytes\" | `bytes${ BytesDataBitSize }`;\r\n\r\n    export type BytesDataBitSize = \r\n        | \"1\" | \"2\" | \"3\" \r\n        | \"4\" | \"5\" | \"6\" \r\n        | \"7\" | \"8\" | \"9\" \r\n        | \"10\" | \"11\" | \"12\" \r\n        | \"13\" | \"14\" | \"15\" \r\n        | \"16\" | \"17\" | \"18\" \r\n        | \"19\" | \"20\" | \"21\" \r\n        | \"22\" | \"23\" | \"24\" \r\n        | \"25\" | \"26\" | \"27\" \r\n        | \"28\" | \"29\" | \"30\" \r\n        | \"31\" | \"32\";\r\n\r\n    export type ArithmeticData = \"uint\" | \"int\" | `${ \"uint\" | \"int\" }${ ArithmeticDataBitSize }`;\r\n\r\n    export type ArithmeticDataBitSize = \r\n        | \"8\" \r\n        | \"16\" | \"24\" | \"32\" \r\n        | \"40\" | \"48\" | \"56\" \r\n        | \"64\" | \"72\" | \"80\" \r\n        | \"88\" | \"96\" \r\n        | \"104\" | \"112\" | \"120\" \r\n        | \"128\" | \"136\" | \"144\" \r\n        | \"152\" | \"160\" | \"168\" \r\n        | \"176\" | \"184\" | \"192\" \r\n        | \"200\" | \"208\" | \"216\" \r\n        | \"224\" | \"232\" | \"240\" \r\n        | \"248\" | \"256\";\r\n\r\n    export type AbstractBinaryInterface = Array<Signature> | Array<object>;\r\n\r\n    export type Bytecode = string;\r\n\r\n    export type Address = `0x${ string }`;\r\n}"],"mappings":"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","names":["address","nonce","e","Wallet","name"]}