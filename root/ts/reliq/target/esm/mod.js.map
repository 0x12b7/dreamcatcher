{"version":3,"sources":["../../src/util/to_string.ts","../../src/util/clone.ts","../../src/unsafe/unsafe.ts","../../src/type/trait/branded_struct.ts","../../src/type/trait/branded.ts","../../src/performance/object_pool/dyn.ts","../../src/math/vec.ts","../../src/math/fpv.ts","../../src/event/ref.ts","../../src/error/variant/dom_error.ts","../../src/error/error_handler.ts","../../src/constant/internal_error_message.ts"],"sourcesContent":["/** \r\n * ***Brief***\r\n * Converts `unknown` to `string`.\r\n * \r\n * ***Warning***\r\n * Does not support circular references and circular objects will result in `[object Object]`.\r\n * \r\n * ***Example***\r\n *  ```ts\r\n *  console.log(toString(42));          /// 42\r\n *  console.log(toString(true));        /// true\r\n *  console.log(toString(null));        /// null\r\n *  console.log(toString(undefined));   /// undefined\r\n * \r\n *  console.log(toString(\"example\"));   /// example\r\n * \r\n *  let object: {\r\n *      color: string;\r\n *      speed: {\r\n *          min: number,\r\n *          max: number\r\n *      }\r\n *  } = {\r\n *      color: \"Blue\",\r\n *      speed: {\r\n *          min: 0,\r\n *          max: 500\r\n *      }\r\n *  };\r\n *  console.log(object);                /// {\"color\":\"Blue\",\"speed\":{\"min\":0,\"max\":500}}\r\n * \r\n *  function foo(): void {\r\n *      let x: string = 500;\r\n *      return x;\r\n *  }\r\n *  console.log(foo);                   /// function foo() {\r\n *                                      ///     x = 500;\r\n *                                      ///     return x;\r\n *                                      /// }\r\n *  ```\r\n */\r\nexport function toString(unknown: unknown): string {\r\n    if (unknown === null || unknown === undefined || typeof unknown !== \"object\") return String(unknown);\r\n    try {\r\n        return JSON.stringify(unknown);\r\n    }\r\n    catch {}\r\n    return \"[object Object]\";\r\n}","import { type Result } from \"@root\";\r\nimport { DomError } from \"@root\";\r\nimport { wrap } from \"@root\";\r\n\r\n/**\r\n * ***Brief***\r\n * Creates a deep clone of the provided value using the structuredClone API.\r\n * \r\n * ***Example***\r\n * ```ts\r\n *  clone()\r\n *      .resolve(e => {\r\n *          if (e.code === \"DOM.ERR_DATA_CLONE\") {\r\n *              /// ...\r\n *          }\r\n *      })\r\n *      .unlock();\r\n * ```\r\n */\r\nexport function clone<T1>(value: T1): Result<T1, DomError> {\r\n    return wrap(() => {\r\n        return structuredClone(value);\r\n    }).mapErr(unsafe => {\r\n        return unsafe\r\n            .parse((instance): instance is DOMException => {\r\n                return instance !== null\r\n                    && instance !== undefined\r\n                    && typeof instance === \"object\"\r\n                    && \"name\" in instance\r\n                    && \"code\" in instance\r\n                    && \"message\" in instance\r\n                    && typeof instance.name === \"string\"\r\n                    && typeof instance.code === \"number\"\r\n                    && typeof instance.message === \"string\";\r\n            })\r\n            .map(exception => {\r\n                return DomError(exception);\r\n            })\r\n            .unwrapOr(DomError());\r\n    });\r\n}","import { type RecoveryWrapper } from \"@root\";\r\nimport { type Parsable } from \"@root\";\r\nimport { type TypeGuard } from \"@root\";\r\nimport { type Option } from \"@root\";\r\nimport { Some } from \"@root\";\r\nimport { None } from \"@root\";\r\n\r\nexport type Unsafe =\r\n    & RecoveryWrapper<unknown>\r\n    & Parsable;\r\n\r\nexport function Unsafe(_value: unknown): Unsafe {\r\n    /***/ {\r\n        return { inspect, parse };\r\n    }\r\n\r\n    function inspect(): unknown {\r\n        return _value;\r\n    }\r\n\r\n    function parse<T1>(guard: TypeGuard<T1>): Option<T1> {\r\n        if (!guard(inspect())) return None;\r\n        return Some((inspect() as T1));\r\n    }\r\n}","import type { Closure } from \"@root\";\r\n\r\n/**\r\n * ***Brief***\r\n * Utility type for creating branded types with a unique string literal identifier `T1`.\r\n * \r\n * ***Example***\r\n * ```ts\r\n *  type Foo = \r\n *      & BrandedStruct<\"Foo\">\r\n *      & {\r\n *      foo: void;\r\n *  };\r\n * \r\n *  type Bar =\r\n *      & BrandedStruct<\"Bar\">\r\n *      & {\r\n *      foo: void;\r\n *  };\r\n * \r\n *  let union: Foo | Bar;\r\n *  if (union.type === \"Foo\") {\r\n *      /// ...\r\n *  }\r\n * ```\r\n */\r\nexport type BrandedStruct<T1 extends string> = {\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Type-level marker specifying the unique type identifier `T1`.\r\n     *\r\n     * ***Example***\r\n     * ```ts\r\n     *  type Foo = \r\n     *      & BrandedStruct<\"Foo\">\r\n     *      & {\r\n     *      foo: void;\r\n     *  };\r\n     * \r\n     *  type Bar =\r\n     *      & BrandedStruct<\"Bar\">\r\n     *      & {\r\n     *      foo: void;\r\n     *  };\r\n     * \r\n     *  let union: Foo | Bar;\r\n     *  if (union.type === \"Foo\") {\r\n     *      /// ...\r\n     *  }\r\n     * ```\r\n     */\r\n    type: T1;\r\n};\r\n\r\nexport namespace BrandedStruct {\r\n    export type Task<T1 extends string> = Closure<[value: BrandedStruct<T1>], void>;\r\n\r\n    export type Handler = {\r\n        match<T1 extends string = any>(unknown: unknown): unknown is BrandedStruct<T1>;\r\n        match<T1 extends string = any>(unknown: unknown, task: Task<T1>): unknown is BrandedStruct<T1>;\r\n        match<T1 extends string>(unknown: unknown, brand: T1): unknown is BrandedStruct<T1>;\r\n        match<T1 extends string>(unknown: unknown, brand: T1, task: Task<T1>): unknown is BrandedStruct<T1>;\r\n    };\r\n\r\n    export const Handler: Handler = (() => {\r\n        /** @constructor */ {\r\n            return { match };\r\n        }\r\n\r\n        function match<T1 extends string = any>(unknown: unknown): unknown is BrandedStruct<T1>;\r\n        function match<T1 extends string = any>(unknown: unknown, task: Closure<[item: BrandedStruct<T1>], void>): unknown is BrandedStruct<T1>;\r\n        function match<T1 extends string>(unknown: unknown, brand: T1): unknown is BrandedStruct<T1>;\r\n        function match<T1 extends string>(unknown: unknown, brand: T1, task: Closure<[item: BrandedStruct<T1>], void>): unknown is BrandedStruct<T1>;\r\n        function match<T1 extends string>(\r\n            p0: unknown,\r\n            p1?: Task<T1> | T1,\r\n            p2?: Task<T1>\r\n        ): p0 is BrandedStruct<T1> {\r\n            let unknown: unknown = p0;\r\n            if (!_valid(unknown)) return false;\r\n            if (typeof p1 === \"string\") {\r\n                let brand: T1 = p1;\r\n                if (!_valid(unknown, brand)) return false;\r\n            }\r\n            let value: BrandedStruct<T1> = (unknown as BrandedStruct<T1>);\r\n            if (typeof p1 === \"function\") {\r\n                let task: Task<T1> = p1;\r\n                task(value);\r\n                return true;\r\n            }\r\n            if (typeof p2 === \"function\") {\r\n                let task: Task<T1> = p2;\r\n                task(value);\r\n                return true;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        function _valid<T1 extends string>(unknown: unknown): unknown is BrandedStruct<T1>;\r\n        function _valid<T1 extends string>(unknown: unknown, brand: T1): unknown is BrandedStruct<T1>;\r\n        function _valid<T1 extends string>(\r\n            p0: unknown,\r\n            p1?: T1\r\n        ): p0 is BrandedStruct<T1> {\r\n            let unknown: unknown = p0;\r\n            if (!(\r\n                unknown !== null\r\n                && unknown !== undefined\r\n                && typeof unknown === \"object\"\r\n                && \"type\" in unknown\r\n                && typeof unknown.type === \"string\"\r\n            )) return false;\r\n            if (p1 && unknown.type !== p1) return false;\r\n            return true;\r\n        }\r\n    })();\r\n}","import type { Closure } from \"@root\";\r\n\r\n/**\r\n * ***Brief***\r\n * Utility type for creating branded types with a unique string literal identifier `T1`.\r\n * \r\n * ***Example***\r\n * ```ts\r\n *  type Foo = \r\n *      & Branded<\"Foo\">\r\n *      & {\r\n *      foo(): void;\r\n *  };\r\n * \r\n *  type Bar =\r\n *      & Branded<\"Bar\">\r\n *      & {\r\n *      foo(): void;\r\n *  };\r\n * \r\n *  let union: Foo | Bar;\r\n *  if (union.type() === \"Foo\") {\r\n *      /// ...\r\n *  }\r\n * ```\r\n */\r\nexport type Branded<T1 extends string> = {\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Type-level marker method specifying the unique type identifier `T1`.\r\n     *\r\n     * ***Example***\r\n     * ```ts\r\n     *  type Foo = \r\n     *      & Branded<\"Foo\">\r\n     *      & {\r\n     *      foo(): void;\r\n     *  };\r\n     * \r\n     *  type Bar =\r\n     *      & Branded<\"Bar\">\r\n     *      & {\r\n     *      foo(): void;\r\n     *  };\r\n     * \r\n     *  let union: Foo | Bar;\r\n     *  if (union.type() === \"Foo\") {\r\n     *      /// ...\r\n     *  }\r\n     * ```\r\n     */\r\n    type(): T1;\r\n};\r\n\r\nexport namespace Branded {\r\n    export type Task<T1 extends string> = Closure<[value: Branded<T1>], void>;\r\n\r\n    export type Handler = {\r\n        match<T1 extends string = any>(unknown: unknown): unknown is Branded<T1>;\r\n        match<T1 extends string = any>(unknown: unknown, task: Task<T1>): unknown is Branded<T1>;\r\n        match<T1 extends string>(unknown: unknown, brand: T1): unknown is Branded<T1>;\r\n        match<T1 extends string>(unknown: unknown, brand: T1, task: Task<T1>): unknown is Branded<T1>;\r\n    };\r\n\r\n    export const Handler: Handler = (() => {\r\n        /** @constructor */ {\r\n            return { match };\r\n        }\r\n\r\n        function match<T1 extends string = any>(unknown: unknown): unknown is Branded<T1>;\r\n        function match<T1 extends string = any>(unknown: unknown, task: Task<T1>): unknown is Branded<T1>;\r\n        function match<T1 extends string>(unknown: unknown, brand: T1): unknown is Branded<T1>;\r\n        function match<T1 extends string>(unknown: unknown, brand: T1, task: Task<T1>): unknown is Branded<T1>;\r\n        function match<T1 extends string>(\r\n            p0: unknown,\r\n            p1?: Task<T1> | T1,\r\n            p2?: Task<T1>\r\n        ): p0 is Branded<T1> {\r\n            let unknown: unknown = p0;\r\n            if (!_valid(unknown)) return false;\r\n            if (typeof p1 === \"string\") {\r\n                let brand: T1 = p1;\r\n                if (!_valid(unknown, brand)) return false;\r\n            }\r\n            let value: Branded<T1> = (unknown as Branded<T1>);\r\n            if (typeof p1 === \"function\") {\r\n                let task: Task<T1> = p1;\r\n                task(value);\r\n                return true;\r\n            }\r\n            if (typeof p2 === \"function\") {\r\n                let task: Task<T1> = p2;\r\n                task(value);\r\n                return true;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        function _valid<T1 extends string>(unknown: unknown): unknown is Branded<T1>;\r\n        function _valid<T1 extends string>(unknown: unknown, brand: T1): unknown is Branded<T1>;\r\n        function _valid<T1 extends string>(\r\n            p0: unknown,\r\n            p1?: T1\r\n        ): p0 is Branded<T1> {\r\n            let unknown: unknown = p0;\r\n            if (!(\r\n                unknown !== null\r\n                && unknown !== undefined\r\n                && typeof unknown === \"object\"\r\n                && \"type\" in unknown\r\n                && typeof unknown.type === \"function\"\r\n                && typeof unknown.type() === \"string\"\r\n            )) return false;\r\n            if (p1 && unknown.type() !== p1) return false;\r\n            return true;\r\n        }\r\n    })();\r\n}","import { type Closure } from \"@root\";\r\nimport { type Wrapper } from \"@root\";\r\nimport { INTERNAL_ERROR_MESSAGE } from \"@root\";\r\nimport { Option } from \"@root\";\r\nimport { Some } from \"@root\";\r\nimport { None } from \"@root\";\r\n\r\nexport type Dyn<T1> = Alloc<T1> | DeAlloc<T1>;\r\n\r\n/**\r\n * ***Brief***\r\n * A dynamic resource management pattern, allowing for\r\n * allocation and deallocation of resources with proper lifecycle handling.\r\n * \r\n * ***Warning***\r\n * The `Dyn` wrapper must be properly managed to avoid memory leaks. If the wrapper itself is garbage collected \r\n * without its content being explicitly deallocated, the resources it manages will not be recycled \r\n * and made available for reuse. Ensure all allocated resources are deallocated before the `Dyn` instance goes out of scope.\r\n * \r\n * ***Example***\r\n * ```ts\r\n *  type Car = {\r\n *      drive(): void;\r\n *  };\r\n * \r\n *  const Car: DynConstructor<Car, [_model: string]> = Dyn(\r\n *      (_model: string) => {\r\n *          constructor {\r\n *              return { drive };\r\n *          }\r\n * \r\n *          function drive(): void {\r\n *              return \"Vroom.\";\r\n *          }\r\n *      },\r\n *      car => {\r\n *          /// Reset car or any tasks before it is made available again.\r\n *          /// ...\r\n *          return car;\r\n *      }, 32n, \"ModelT\"\r\n *  );\r\n * \r\n *  let car: Dyn<Car> = Car(\"ModelF\");\r\n *  car = car.deAlloc();\r\n *  car.map(car => {\r\n *      /// Will not run because `car` has been deallocated.\r\n *      /// ...\r\n *  });\r\n * ```\r\n * \r\n * ***Example***\r\n * ```ts\r\n *  /// Warning.\r\n *  let car: Dyn<Car> = Car(\"ModelB\");\r\n *  car.deAlloc();\r\n *  car.map(car => {\r\n *      /// Will run because the car must be updated to the new state.\r\n *      /// Always assign the `deAlloc` result a new `Dyn` wrapper or\r\n *      /// itself.\r\n *      /// ...\r\n *  });\r\n * ```\r\n */\r\nexport function Dyn<T1, T2 extends Array<unknown>>(_constructor: Closure<T2, T1>, _onDeAlloc: Closure<[T1], T1>, _load: bigint, ..._onLoadPayload: T2): Dyn.Constructor<T1, T2> {\r\n    let _available: Map<bigint, T1>;\r\n    let _count: bigint;\r\n\r\n    /** @constructor */ {\r\n        _available = new Map();\r\n        _count = 0n;\r\n        let i: bigint = 0n;\r\n        while (i < _load) {\r\n            let key: bigint = _newKey();\r\n            _available.set(key, _constructor(..._onLoadPayload));\r\n            i ++;\r\n        }\r\n        return function (...payload: T2): Dyn<T1> {\r\n            let _key: Option<bigint>;\r\n            let _this: Dyn<T1>;\r\n    \r\n            /** @constructor */ {\r\n                _key = None;\r\n                return _this = alloc();\r\n            }\r\n\r\n            function alloc(): Alloc<T1> {\r\n                return _recycledKey()\r\n                    .toResult(undefined)\r\n                    .map(key => {\r\n                        _key = Some(key);\r\n                        return Alloc(_recyled(key), { deAlloc });\r\n                    })\r\n                    .recover(() => {\r\n                        _key = Some(_newKey());\r\n                        return Alloc(_constructor(...payload), { deAlloc });\r\n                    })\r\n                    .unwrap();            \r\n            }\r\n    \r\n            function deAlloc(): DeAlloc<T1> {\r\n                _key\r\n                    .toResult(undefined)\r\n                    .map(key => {\r\n                        /// If the key is available then it is allocated.\r\n                        _key = None;\r\n                        _recyle(key, _onDeAlloc(_this.expect(\"Dyn: Could not deallocate resource but the key was available.\" + INTERNAL_ERROR_MESSAGE)));\r\n                        return;\r\n                    });\r\n                return _this = DeAlloc({ deAlloc });\r\n            }\r\n        };\r\n    }\r\n\r\n    function _newKey(): bigint {\r\n        return _count += 1n;\r\n    }\r\n\r\n    function _recycledKey(): Option<bigint> {\r\n        let key: bigint | undefined = _available\r\n            .keys()\r\n            .toArray()\r\n            .at(0);\r\n        if (!key) return None;\r\n        return Some(key);\r\n    }\r\n\r\n    function _recyled(key: bigint): T1 {\r\n        let value: T1 = _available.get(key)!;\r\n        _available.delete(key);\r\n        return value;\r\n    }\r\n\r\n    function _recyle(key: bigint, value: T1): void {\r\n        _available.set(key, value);\r\n        return;\r\n    }\r\n}\r\n\r\nexport namespace Dyn {\r\n    export type Constructor<T1, T2 extends Array<unknown>> = Closure<T2, Dyn<T1>>;\r\n\r\n    export type Wrapper<T1> = {\r\n\r\n        /**\r\n         * ***Brief***\r\n         * Deallocates a resource, making it available for recycling.\r\n         * \r\n         * ***Example***\r\n         * ```ts\r\n         *  let personD: Dyn<{ name: string }>;\r\n         *  personD\r\n         *      .deAlloc()\r\n         *      .map(person => {\r\n         *          /// Not run because `person` was deallocated.\r\n         *          /// ...\r\n         *      });\r\n         * ```\r\n         */\r\n        deAlloc(): DeAlloc<T1>;\r\n    };\r\n}\r\n\r\n\r\nexport type Alloc<T1> =\r\n    & Dyn.Wrapper<T1>\r\n    & Some<T1>\r\n    & Wrapper<T1>;\r\n    \r\nexport function Alloc<T1>(_value: T1, _dyn: Dyn.Wrapper<T1>): Alloc<T1> {\r\n    {\r\n        return { ... Some(_value), ... _dyn };\r\n    }\r\n}\r\n\r\n\r\nexport type DeAlloc<T1> = \r\n    & None\r\n    & Dyn.Wrapper<T1>;\r\n\r\n/**\r\n * ***Brief***\r\n * The deallocated state of an allocated resource.\r\n */\r\nexport function DeAlloc<T1>(_dyn: Dyn.Wrapper<T1>): DeAlloc<T1> {\r\n    {\r\n        return { ... None, ... _dyn };\r\n    }\r\n}","import { INTERNAL_ERROR_MESSAGE } from \"@root\";\r\nimport { Fpv } from \"@root\";\r\n\r\nexport type Vec<T1 extends Fpv.Decimals> = {\r\n    decimals(): T1;\r\n    x(): Fpv<T1>;\r\n    y(): Fpv<T1>;\r\n    distanceFrom(origin: Vec<T1>): Fpv.Result<Fpv<T1>>;\r\n};\r\n\r\nexport function Vec<T1 extends Fpv.Decimals, T2 extends T1 = T1>(_x: Fpv.Compatible<T1>, _y: Fpv.Compatible<T2>, _decimals: T1): Vec<T1> {\r\n    /***/ {\r\n        return {\r\n            decimals,\r\n            x,\r\n            y,\r\n            distanceFrom\r\n        };\r\n    }\r\n\r\n    function decimals(): T1 {\r\n        return _decimals;\r\n    }\r\n\r\n    function x(): Fpv<T1> {\r\n        return Fpv(Fpv.Calculator.unwrap(_x), decimals()).expect(INTERNAL_ERROR_MESSAGE);\r\n    }\r\n\r\n    function y(): Fpv<T1> {\r\n        return Fpv(Fpv.Calculator.unwrap(_y), decimals()).expect(INTERNAL_ERROR_MESSAGE);\r\n    }\r\n\r\n    function distanceFrom(origin: Vec<T1>): Fpv.Result<Fpv<T1>> {\r\n        let dx: Fpv<T1> = origin.x().sub(x());\r\n        let dy: Fpv<T1> = origin.y().sub(y());\r\n        return dx\r\n            .mul(dx)\r\n            .add(dy.mul(dy))\r\n            .sqrt();\r\n    }\r\n}\r\n\r\nexport namespace Vec {}","import { \r\n    type Wrapper,\r\n    INTERNAL_ERROR_MESSAGE,\r\n    Result,\r\n    Ok,\r\n    Err\r\n} from \"@root\";\r\n\r\ntype Result$0<T1, T2> = Result<T1, T2>;\r\n\r\nexport type Fpv<T1 extends Fpv.Decimals> = \r\n    & Wrapper<bigint>\r\n    & {\r\n    decimals(): T1;\r\n    representation(): bigint;\r\n    eq(x: bigint): boolean;\r\n    eq(x: Fpv<T1>): boolean;\r\n    eq(x: Fpv.Compatible<T1>): boolean;\r\n    lt(x: bigint): boolean;\r\n    lt(x: Fpv<T1>): boolean;\r\n    lt(x: Fpv.Compatible<T1>): boolean;\r\n    gt(x: bigint): boolean;\r\n    gt(x: Fpv<T1>): boolean;\r\n    gt(x: Fpv.Compatible<T1>): boolean;\r\n    lteq(x: bigint): boolean;\r\n    lteq(x: Fpv<T1>): boolean;\r\n    lteq(x: Fpv.Compatible<T1>): boolean;\r\n    gteq(x: bigint): boolean;\r\n    gteq(x: Fpv<T1>): boolean;\r\n    gteq(x: Fpv.Compatible<T1>): boolean;\r\n    add(x: bigint): Fpv<T1>;\r\n    add(x: Fpv<T1>): Fpv<T1>;\r\n    add(x: Fpv.Compatible<T1>): Fpv<T1>;\r\n    sub(x: bigint): Fpv<T1>;\r\n    sub(x: Fpv<T1>): Fpv<T1>;\r\n    sub(x: Fpv.Compatible<T1>): Fpv<T1>;\r\n    mul(x: bigint): Fpv<T1>;\r\n    mul(x: Fpv<T1>): Fpv<T1>;\r\n    mul(x: Fpv.Compatible<T1>): Fpv<T1>;\r\n    div(x: bigint): Fpv.Result<Fpv<T1>>;\r\n    div(x: Fpv<T1>): Fpv.Result<Fpv<T1>>;\r\n    div(x: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>>;\r\n    pow(x: bigint): Fpv.Result<Fpv<T1>>;\r\n    pow(x: Fpv<T1>): Fpv.Result<Fpv<T1>>;\r\n    pow(x: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>>;\r\n    sqrt(): Fpv.Result<Fpv<T1>>;\r\n    convert<T2 extends Fpv.Decimals>(decimals: T2): Fpv.Result<Fpv<T2>>;\r\n    percentageOf(x: bigint): Fpv.Result<Fpv<T1>>;\r\n    percentageOf(x: Fpv<T1>): Fpv.Result<Fpv<T1>>;\r\n    percentageOf(x: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>>;\r\n    percentageGain(newValue: bigint): Fpv.Result<Fpv<T1>>;\r\n    percentageGain(newValue: Fpv<T1>): Fpv.Result<Fpv<T1>>;\r\n    percentageGain(newValue: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>>;\r\n    percentageLoss(newValue: bigint): Fpv.Result<Fpv<T1>>;\r\n    percentageLoss(newValue: Fpv<T1>): Fpv.Result<Fpv<T1>>;\r\n    percentageLoss(newValue: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>>;\r\n    percentageChange(newValue: bigint): Fpv.Result<Fpv<T1>>;\r\n    percentageChange(newValue: Fpv<T1>): Fpv.Result<Fpv<T1>>;\r\n    percentageChange(newValue: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>>;\r\n    sliceOf(percentage: bigint): Fpv.Result<Fpv<T1>>;\r\n    sliceOf(percentage: Fpv<T1>): Fpv.Result<Fpv<T1>>;\r\n    sliceOf(percentage: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>>;\r\n    addPercentage(percentage: bigint): Fpv.Result<Fpv<T1>>;\r\n    addPercentage(percentage: Fpv<T1>): Fpv.Result<Fpv<T1>>;\r\n    addPercentage(percentage: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>>;\r\n    subPercentage(percentage: bigint): Fpv.Result<Fpv<T1>>;\r\n    subPercentage(percentage: Fpv<T1>): Fpv.Result<Fpv<T1>>;\r\n    subPercentage(percentage: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>>;\r\n};\r\n\r\n/**\r\n * ***Warning***\r\n * Does not support negative `decimals`.\r\n */\r\nexport function Fpv<T1 extends Fpv.Decimals>(_v: Fpv.Compatible<T1>, _decimals: T1): Fpv.Result<Fpv<T1>> {\r\n    /***/ {\r\n        if (decimals() < 0n) return Err(\"FPV.ERR_NEGATIVE_DECIMALS\");\r\n        return Ok({\r\n            unwrap,\r\n            decimals,\r\n            representation,\r\n            eq,\r\n            lt,\r\n            gt,\r\n            lteq,\r\n            gteq,\r\n            add,\r\n            sub,\r\n            mul,\r\n            div,\r\n            pow,\r\n            sqrt,\r\n            convert,\r\n            percentageOf,\r\n            percentageGain,\r\n            percentageLoss,\r\n            percentageChange,\r\n            sliceOf,\r\n            addPercentage,\r\n            subPercentage\r\n        });\r\n    }\r\n\r\n    function unwrap(): bigint {\r\n        return Fpv.Calculator.unwrap(_v);\r\n    }\r\n\r\n    function decimals(): T1 {\r\n        return _decimals;\r\n    }\r\n\r\n    function representation(): bigint {\r\n        return 10n ** decimals();\r\n    }\r\n\r\n    function eq(x: bigint): boolean;\r\n    function eq(x: Fpv<T1>): boolean;\r\n    function eq(x: Fpv.Compatible<T1>): boolean {\r\n        return Fpv.Calculator.eq(_v, x);\r\n    }\r\n\r\n    function lt(x: bigint): boolean;\r\n    function lt(x: Fpv<T1>): boolean;\r\n    function lt(x: Fpv.Compatible<T1>): boolean {\r\n        return Fpv.Calculator.lt(_v, x);\r\n    }\r\n\r\n    function gt(x: bigint): boolean;\r\n    function gt(x: Fpv<T1>): boolean;\r\n    function gt(x: Fpv.Compatible<T1>): boolean {\r\n        return Fpv.Calculator.gt(_v, x);\r\n    }\r\n\r\n    function lteq(x: bigint): boolean;\r\n    function lteq(x: Fpv<T1>): boolean;\r\n    function lteq(x: Fpv.Compatible<T1>): boolean {\r\n        return Fpv.Calculator.lteq(_v, x);\r\n    }\r\n\r\n    function gteq(x: bigint): boolean;\r\n    function gteq(x: Fpv<T1>): boolean;\r\n    function gteq(x: Fpv.Compatible<T1>): boolean {\r\n        return Fpv.Calculator.gteq(_v, x);\r\n    }\r\n\r\n    function add(x: bigint): Fpv<T1>;\r\n    function add(x: Fpv<T1>): Fpv<T1>;\r\n    function add(x: Fpv.Compatible<T1>): Fpv<T1> {\r\n        return Fpv.Calculator\r\n            .add(_v, x, decimals())\r\n            .expect(INTERNAL_ERROR_MESSAGE);\r\n    }\r\n\r\n    function sub(x: bigint): Fpv<T1>;\r\n    function sub(x: Fpv<T1>): Fpv<T1>;\r\n    function sub(x: Fpv.Compatible<T1>): Fpv<T1> {\r\n        return Fpv.Calculator\r\n            .sub(_v, x, decimals())\r\n            .expect(INTERNAL_ERROR_MESSAGE);\r\n    }\r\n\r\n    function mul(x: bigint): Fpv<T1>;\r\n    function mul(x: Fpv<T1>): Fpv<T1>;\r\n    function mul(x: Fpv.Compatible<T1>): Fpv<T1> {\r\n        return Fpv.Calculator\r\n            .mul(_v, x, decimals())\r\n            .expect(INTERNAL_ERROR_MESSAGE);\r\n    }\r\n\r\n    function div(x: bigint): Fpv.Result<Fpv<T1>>;\r\n    function div(x: Fpv<T1>): Fpv.Result<Fpv<T1>>;\r\n    function div(x: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>> {\r\n        return Fpv.Calculator.div(_v, x, decimals());\r\n    }\r\n\r\n    function pow(x: bigint): Fpv.Result<Fpv<T1>>;\r\n    function pow(x: Fpv<T1>): Fpv.Result<Fpv<T1>>;\r\n    function pow(x: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>> {\r\n        return Fpv.Calculator.pow(_v, x, decimals());\r\n    }\r\n\r\n    function sqrt(): Fpv.Result<Fpv<T1>> {\r\n        return Fpv.Calculator.sqrt(_v, decimals());\r\n    }\r\n\r\n    function convert<T2 extends Fpv.Decimals>(decimals$0: T2): Fpv.Result<Fpv<T2>> {\r\n        return Fpv.Calculator.convert(_v, decimals(), decimals$0);\r\n    }\r\n\r\n    function percentageOf(x: bigint): Fpv.Result<Fpv<T1>>;\r\n    function percentageOf(x: Fpv<T1>): Fpv.Result<Fpv<T1>>;\r\n    function percentageOf(x: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>> {\r\n        return Fpv.Calculator.percentageOf(_v, x, decimals());\r\n    }\r\n\r\n    function percentageGain(newValue: bigint): Fpv.Result<Fpv<T1>>;\r\n    function percentageGain(newValue: Fpv<T1>): Fpv.Result<Fpv<T1>>;\r\n    function percentageGain(newValue: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>> {\r\n        return Fpv.Calculator.percentageGain(_v, newValue, decimals());\r\n    }\r\n\r\n    function percentageLoss(newValue: bigint): Fpv.Result<Fpv<T1>>;\r\n    function percentageLoss(newValue: Fpv<T1>): Fpv.Result<Fpv<T1>>;\r\n    function percentageLoss(newValue: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>> {\r\n        return Fpv.Calculator.percentageLoss(_v, newValue, decimals());\r\n    }\r\n\r\n    function percentageChange(newValue: bigint): Fpv.Result<Fpv<T1>>;\r\n    function percentageChange(newValue: Fpv<T1>): Fpv.Result<Fpv<T1>>;\r\n    function percentageChange(newValue: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>> {\r\n        return Fpv.Calculator.percentageChange(_v, newValue, decimals());\r\n    }\r\n\r\n    function sliceOf(percentage: bigint): Fpv.Result<Fpv<T1>>;\r\n    function sliceOf(percentage: Fpv<T1>): Fpv.Result<Fpv<T1>>;\r\n    function sliceOf(percentage: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>> {\r\n        return Fpv.Calculator.sliceOf(_v, percentage, decimals());\r\n    }\r\n\r\n    function addPercentage(percentage: bigint): Fpv.Result<Fpv<T1>>;\r\n    function addPercentage(percentage: Fpv<T1>): Fpv.Result<Fpv<T1>>;\r\n    function addPercentage(percentage: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>> {\r\n        return Fpv.Calculator.addPercentage(_v, percentage, decimals());\r\n    }\r\n\r\n    function subPercentage(percentage: bigint): Fpv.Result<Fpv<T1>>;\r\n    function subPercentage(percentage: Fpv<T1>): Fpv.Result<Fpv<T1>>;\r\n    function subPercentage(percentage: Fpv.Compatible<T1>): Fpv.Result<Fpv<T1>> {\r\n        return Fpv.Calculator.subPercentage(_v, percentage, decimals());\r\n    }\r\n}\r\n\r\nexport namespace Fpv {\r\n    export type Result<T1> = Result$0<T1, ErrorCode>;\r\n\r\n    export type ErrorCode = \r\n        | \"FPV.ERR_DIVISION_BY_ZERO\"\r\n        | \"FPV.ERR_NEGATIVE_DECIMALS\"\r\n        | \"FPV.ERR_NEGATIVE_EXPONENT\"\r\n        | \"FPV.ERR_CANNOT_SQUARE_NAGATIVE\";\r\n\r\n    export type Compatible<T1 extends Decimals = Decimals> = Fpv<T1> | bigint;\r\n\r\n    export type Decimals = bigint;\r\n\r\n    export type Calculator = {\r\n        unwrap(value: Compatible<Decimals>): bigint;\r\n        eq<T1 extends Decimals>(x: bigint, y: bigint): boolean;\r\n        eq<T1 extends Decimals>(x: Fpv<T1>, y: bigint): boolean;\r\n        eq<T1 extends Decimals>(x: bigint, y: Fpv<T1>): boolean;\r\n        eq<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>): boolean;\r\n        eq<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>): boolean;\r\n        lt<T1 extends Decimals>(x: bigint, y: bigint): boolean;\r\n        lt<T1 extends Decimals>(x: Fpv<T1>, y: bigint): boolean;\r\n        lt<T1 extends Decimals>(x: bigint, y: Fpv<T1>): boolean;\r\n        lt<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>): boolean;\r\n        lt<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>): boolean;\r\n        gt<T1 extends Decimals>(x: bigint, y: bigint): boolean;\r\n        gt<T1 extends Decimals>(x: Fpv<T1>, y: bigint): boolean;\r\n        gt<T1 extends Decimals>(x: bigint, y: Fpv<T1>): boolean;\r\n        gt<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>): boolean;\r\n        gt<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>): boolean;\r\n        lteq<T1 extends Decimals>(x: bigint, y: bigint): boolean;\r\n        lteq<T1 extends Decimals>(x: Fpv<T1>, y: bigint): boolean;\r\n        lteq<T1 extends Decimals>(x: bigint, y: Fpv<T1>): boolean;\r\n        lteq<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T1>): boolean;\r\n        lteq<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>): boolean;\r\n        gteq<T1 extends Decimals>(x: bigint, y: bigint): boolean;\r\n        gteq<T1 extends Decimals>(x: Fpv<T1>, y: bigint): boolean;\r\n        gteq<T1 extends Decimals>(x: bigint, y: Fpv<T1>): boolean;\r\n        gteq<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T1>): boolean;\r\n        gteq<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>): boolean;\r\n        add<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        add<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        add<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        add<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>, decimals: T1): Result<Fpv<T1>>;\r\n        add<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\r\n        sub<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        sub<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        sub<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        sub<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>, decimals: T1): Result<Fpv<T1>>;\r\n        sub<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\r\n        mul<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        mul<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        mul<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        mul<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>, decimals: T1): Result<Fpv<T1>>;\r\n        mul<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\r\n        div<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        div<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        div<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        div<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>, decimals: T1): Result<Fpv<T1>>;\r\n        div<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\r\n        pow<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        pow<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        pow<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        pow<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>, decimals: T1): Result<Fpv<T1>>;\r\n        pow<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\r\n        sqrt<T1 extends Decimals>(x: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        sqrt<T1 extends Decimals>(x: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        sqrt<T1 extends Decimals>(x: Compatible<T1>, decimals: T1): Result<Fpv<T1>>; \r\n        convert<T1 extends Decimals, T2 extends Decimals>(x: bigint, oldDecimals: T1, newDecimals: T2): Result<Fpv<T2>>;\r\n        convert<T1 extends Decimals, T2 extends Decimals>(x: Fpv<T1>, oldDecimals: T1, newDecimals: T2): Result<Fpv<T2>>;\r\n        convert<T1 extends Decimals, T2 extends Decimals>(x: Compatible<T1>, oldDecimals: T1, newDecimals: T2): Result<Fpv<T2>>;\r\n        percentageOf<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        percentageOf<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        percentageOf<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        percentageOf<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        percentageOf<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\r\n        percentageGain<T1 extends Decimals>(oldValue: bigint, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        percentageGain<T1 extends Decimals>(oldValue: Fpv<T1>, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        percentageGain<T1 extends Decimals>(oldValue: bigint, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        percentageGain<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Fpv<T1>, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        percentageGain<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Compatible<T1>, newValue: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\r\n        percentageLoss<T1 extends Decimals>(oldValue: bigint, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        percentageLoss<T1 extends Decimals>(oldValue: Fpv<T1>, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        percentageLoss<T1 extends Decimals>(oldValue: bigint, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        percentageLoss<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Fpv<T1>, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        percentageLoss<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Compatible<T1>, newValue: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\r\n        percentageChange<T1 extends Decimals>(oldValue: bigint, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        percentageChange<T1 extends Decimals>(oldValue: Fpv<T1>, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        percentageChange<T1 extends Decimals>(oldValue: bigint, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        percentageChange<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Fpv<T1>, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        percentageChange<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Compatible<T1>, newValue: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;        \r\n        sliceOf<T1 extends Decimals>(x: bigint, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        sliceOf<T1 extends Decimals>(x: Fpv<T1>, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        sliceOf<T1 extends Decimals>(x: bigint, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        sliceOf<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        sliceOf<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, percentage: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\r\n        addPercentage<T1 extends Decimals>(x: bigint, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        addPercentage<T1 extends Decimals>(x: Fpv<T1>, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        addPercentage<T1 extends Decimals>(x: bigint, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        addPercentage<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        addPercentage<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, percentage: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\r\n        subPercentage<T1 extends Decimals>(x: bigint, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        subPercentage<T1 extends Decimals>(x: Fpv<T1>, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        subPercentage<T1 extends Decimals>(x: bigint, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        subPercentage<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        subPercentage<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, percentage: Compatible<T2>, decimals: T1): Result<Fpv<T1>>;\r\n    };\r\n\r\n    export const Calculator: Calculator = (() => {\r\n        /***/ {\r\n            return {\r\n                unwrap,\r\n                eq,\r\n                lt,\r\n                gt,\r\n                lteq,\r\n                gteq,\r\n                add,\r\n                sub,\r\n                mul,\r\n                div,\r\n                pow,\r\n                sqrt,\r\n                convert,\r\n                percentageOf,\r\n                percentageGain,\r\n                percentageLoss,\r\n                percentageChange,\r\n                sliceOf,\r\n                addPercentage,\r\n                subPercentage\r\n            };\r\n        }\r\n\r\n        function unwrap(value: Compatible<Decimals>): bigint {\r\n            return typeof value === \"bigint\" ? value : value.unwrap();\r\n        }\r\n\r\n        function eq<T1 extends Decimals>(x: bigint, y: bigint): boolean;\r\n        function eq<T1 extends Decimals>(x: Fpv<T1>, y: bigint): boolean;\r\n        function eq<T1 extends Decimals>(x: bigint, y: Fpv<T1>): boolean;\r\n        function eq<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>): boolean;\r\n        function eq<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>): boolean {\r\n            return unwrap(x) === unwrap(y);\r\n        }\r\n\r\n        function lt<T1 extends Decimals>(x: bigint, y: bigint): boolean;\r\n        function lt<T1 extends Decimals>(x: Fpv<T1>, y: bigint): boolean;\r\n        function lt<T1 extends Decimals>(x: bigint, y: Fpv<T1>): boolean;\r\n        function lt<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>): boolean;\r\n        function lt<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>): boolean {\r\n            return unwrap(x) < unwrap(y);\r\n        }\r\n\r\n        function gt<T1 extends Decimals>(x: bigint, y: bigint): boolean;\r\n        function gt<T1 extends Decimals>(x: Fpv<T1>, y: bigint): boolean;\r\n        function gt<T1 extends Decimals>(x: bigint, y: Fpv<T1>): boolean;\r\n        function gt<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>): boolean;\r\n        function gt<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>): boolean {\r\n            return unwrap(x) > unwrap(y);\r\n        }\r\n\r\n        function lteq<T1 extends Decimals>(x: bigint, y: bigint): boolean;\r\n        function lteq<T1 extends Decimals>(x: Fpv<T1>, y: bigint): boolean;\r\n        function lteq<T1 extends Decimals>(x: bigint, y: Fpv<T1>): boolean;\r\n        function lteq<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T1>): boolean;\r\n        function lteq<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>): boolean {\r\n            return unwrap(x) <= unwrap(y);\r\n        }\r\n\r\n        function gteq<T1 extends Decimals>(x: bigint, y: bigint): boolean;\r\n        function gteq<T1 extends Decimals>(x: Fpv<T1>, y: bigint): boolean;\r\n        function gteq<T1 extends Decimals>(x: bigint, y: Fpv<T1>): boolean;\r\n        function gteq<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T1>): boolean;\r\n        function gteq<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>): boolean {\r\n            return unwrap(x) >= unwrap(y);\r\n        }\r\n\r\n        function add<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function add<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function add<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        function add<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>, decimals: T1): Result<Fpv<T1>>;\r\n        function add<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\r\n            return Fpv<T1>(unwrap(x) + unwrap(y), decimals);\r\n        }\r\n\r\n        function sub<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function sub<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function sub<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        function sub<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>, decimals: T1): Result<Fpv<T1>>;\r\n        function sub<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\r\n            return Fpv<T1>(unwrap(x) - unwrap(y), decimals);\r\n        }\r\n\r\n        function mul<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function mul<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function mul<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        function mul<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>, decimals: T1): Result<Fpv<T1>>;\r\n        function mul<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\r\n            let x$0: bigint = unwrap(x);\r\n            let y$0: bigint = unwrap(y);\r\n            let z: bigint = x$0 * y$0;\r\n            if (decimals === 0n) return Fpv<T1>(z, decimals);\r\n            return Fpv<T1>(z / (10n ** decimals), decimals);\r\n        }\r\n\r\n        function div<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function div<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function div<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        function div<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>, decimals: T1): Result<Fpv<T1>>;\r\n        function div<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\r\n            let x$0: bigint = unwrap(x);\r\n            let y$0: bigint = unwrap(y);\r\n            if (y$0 === 0n) return Err(\"FPV.ERR_DIVISION_BY_ZERO\");\r\n            if (decimals === 0n) return Ok(Fpv(x$0 / y$0, decimals).expect(INTERNAL_ERROR_MESSAGE));    \r\n            let z: bigint = x$0 * (10n ** decimals);\r\n            let q: bigint = z / y$0;\r\n            return Ok(Fpv(q, decimals).expect(INTERNAL_ERROR_MESSAGE));\r\n        }\r\n\r\n        function pow<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function pow<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function pow<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        function pow<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T2>, decimals: T1): Result<Fpv<T1>>;\r\n        function pow<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\r\n            let base: bigint = unwrap(x);\r\n            let exponent: bigint = unwrap(y);\r\n            if (exponent < 0n) return Err(\"FPV.ERR_NEGATIVE_EXPONENT\");\r\n            let result: bigint = 1n;\r\n            while (exponent > 0n) {\r\n                if (exponent % 2n === 1n) result = (result * base) / (10n ** decimals);\r\n                base = (base * base) / (10n ** decimals);\r\n                exponent /= 2n;\r\n            }\r\n            let result$0: Result<Fpv<T1>> = convert(result, 0n, decimals);\r\n            if (result$0.err()) return result$0;\r\n            let result$1: Fpv<T1> = result$0.unwrap();\r\n            let result$2: bigint = result$1.unwrap();\r\n            return Fpv(result$2, decimals);\r\n        }\r\n\r\n        function sqrt<T1 extends Decimals>(x: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function sqrt<T1 extends Decimals>(x: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        function sqrt<T1 extends Decimals>(x: Compatible<T1>, decimals: T1): Result<Fpv<T1>> {\r\n            let x$0: bigint = unwrap(x);\r\n            if (x$0 < 0n) return Err(\"FPV.ERR_CANNOT_SQUARE_NAGATIVE\");\r\n            if (x$0 === 0n) return Fpv(0n, decimals);\r\n            let one: bigint = 10n ** decimals;\r\n            one *= x$0;\r\n            let x$1: bigint = one;\r\n            let y: bigint;\r\n            do {\r\n                y = x$1;\r\n                x$1 = (y + one / y) / 2n; \r\n            }\r\n            while(x$1 !== y);\r\n            return Fpv(x$1, decimals);\r\n        }\r\n\r\n        function convert<T1 extends Decimals, T2 extends Decimals>(x: bigint, oldDecimals: T1, newDecimals: T2): Result<Fpv<T2>>;\r\n        function convert<T1 extends Decimals, T2 extends Decimals>(x: Fpv<T1>, oldDecimals: T1, newDecimals: T2): Result<Fpv<T2>>;\r\n        function convert<T1 extends Decimals, T2 extends Decimals>(x: Compatible<T1>, oldDecimals: T1, newDecimals: T2): Result<Fpv<T2>> {\r\n            if (oldDecimals < 0n) return Err(\"FPV.ERR_NEGATIVE_DECIMALS\");\r\n            if (newDecimals < 0n) return Err(\"FPV.ERR_NEGATIVE_DECIMALS\");\r\n            let x$0: bigint = unwrap(x);\r\n            let scl: bigint;\r\n            if (newDecimals > oldDecimals) {\r\n                scl = 10n ** (newDecimals - oldDecimals as unknown as bigint);\r\n                x$0 *= scl;\r\n            }\r\n            if (newDecimals < oldDecimals) {\r\n                scl = 10n ** (oldDecimals - newDecimals as unknown as bigint);\r\n                x$0 /= scl;\r\n            }\r\n            return Ok(Fpv(x$0, newDecimals).expect(INTERNAL_ERROR_MESSAGE));\r\n        }\r\n\r\n        function percentageOf<T1 extends Decimals>(x: bigint, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function percentageOf<T1 extends Decimals>(x: Fpv<T1>, y: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function percentageOf<T1 extends Decimals>(x: bigint, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        function percentageOf<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, y: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        function percentageOf<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, y: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\r\n            let x$0: bigint = unwrap(x);\r\n            let y$0: bigint = unwrap(y);\r\n            let z: Result<Fpv<T1>> = div(x$0, y$0, decimals);\r\n            if (z.err()) return z;\r\n            let z$0: bigint = z\r\n                .unwrap()\r\n                .unwrap();\r\n            let representation: bigint = 10n**decimals;\r\n            return mul(z$0, 100n * representation, decimals);\r\n        }\r\n\r\n        function percentageGain<T1 extends Decimals>(oldValue: bigint, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function percentageGain<T1 extends Decimals>(oldValue: Fpv<T1>, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function percentageGain<T1 extends Decimals>(oldValue: bigint, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        function percentageGain<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Fpv<T1>, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        function percentageGain<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Compatible<T1>, newValue: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\r\n            let oldValue$0: bigint = unwrap(oldValue);\r\n            let newValue$0: bigint = unwrap(newValue);\r\n            if (newValue$0 <= oldValue$0) return Fpv(0n, decimals);\r\n            return sub(newValue$0, oldValue$0, decimals)\r\n                .and(value => {\r\n                    return div(value, oldValue$0, decimals);\r\n                })\r\n                .and(value => {\r\n                    return mul(value, 100n * (10n**decimals), decimals);\r\n                })\r\n                .mapErr(e => {\r\n                    return e as ErrorCode;\r\n                });\r\n        }\r\n\r\n        function percentageLoss<T1 extends Decimals>(oldValue: bigint, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function percentageLoss<T1 extends Decimals>(oldValue: Fpv<T1>, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function percentageLoss<T1 extends Decimals>(oldValue: bigint, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        function percentageLoss<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Fpv<T1>, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        function percentageLoss<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Compatible<T1>, newValue: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\r\n            let oldValue$0: bigint = unwrap(oldValue);\r\n            let newValue$0: bigint = unwrap(newValue);\r\n            if (newValue$0 >= oldValue$0) return Fpv(0n, decimals);\r\n            return sub(newValue$0, oldValue$0, decimals)\r\n                .and(value => {\r\n                    return div(value, oldValue$0, decimals)\r\n                })\r\n                .and(value => {\r\n                    return mul(value, 100n * (10n**decimals), decimals);\r\n                })\r\n                .mapErr(e => {\r\n                    return e as ErrorCode;\r\n                });\r\n        }\r\n\r\n        function percentageChange<T1 extends Decimals>(oldValue: bigint, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function percentageChange<T1 extends Decimals>(oldValue: Fpv<T1>, newValue: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function percentageChange<T1 extends Decimals>(oldValue: bigint, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        function percentageChange<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Fpv<T1>, newValue: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        function percentageChange<T1 extends Decimals, T2 extends T1 = T1>(oldValue: Compatible<T1>, newValue: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\r\n            let oldValue$0: bigint = unwrap(oldValue);\r\n            let newValue$0: bigint = unwrap(newValue);\r\n            if (newValue$0 <= oldValue$0) return percentageLoss(oldValue$0, newValue$0, decimals);\r\n            return percentageGain(oldValue$0, newValue$0, decimals);\r\n        }\r\n\r\n        function sliceOf<T1 extends Decimals>(x: bigint, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function sliceOf<T1 extends Decimals>(x: Fpv<T1>, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function sliceOf<T1 extends Decimals>(x: bigint, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        function sliceOf<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        function sliceOf<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, percentage: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\r\n            let x$0: bigint = unwrap(x);\r\n            let percentage$0: bigint = unwrap(percentage);\r\n            let z: Result<Fpv<T1>> = div<T1>(x$0, 100n * (10n**decimals), decimals);\r\n            if (z.err()) return z;\r\n            let z$0: Fpv<T1> = z.unwrap();\r\n            return mul(z$0, percentage$0, decimals);\r\n        }\r\n\r\n        function addPercentage<T1 extends Decimals>(x: bigint, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function addPercentage<T1 extends Decimals>(x: Fpv<T1>, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function addPercentage<T1 extends Decimals>(x: bigint, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        function addPercentage<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        function addPercentage<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, percentage: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\r\n            let x$0: bigint = unwrap(x);\r\n            let percentage$0: bigint = unwrap(percentage);\r\n            return sliceOf(x$0, percentage$0, decimals).and(y => {\r\n                return add(x$0, y, decimals);\r\n            });\r\n        }\r\n\r\n        function subPercentage<T1 extends Decimals>(x: bigint, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function subPercentage<T1 extends Decimals>(x: Fpv<T1>, percentage: bigint, decimals: T1): Result<Fpv<T1>>;\r\n        function subPercentage<T1 extends Decimals>(x: bigint, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        function subPercentage<T1 extends Decimals, T2 extends T1 = T1>(x: Fpv<T1>, percentage: Fpv<T1>, decimals: T1): Result<Fpv<T1>>;\r\n        function subPercentage<T1 extends Decimals, T2 extends T1 = T1>(x: Compatible<T1>, percentage: Compatible<T2>, decimals: T1): Result<Fpv<T1>> {\r\n            let x$0: bigint = unwrap(x);\r\n            let percentage$0: bigint = unwrap(percentage);\r\n            return sliceOf(x$0, percentage$0, decimals).and(y => {\r\n                return sub(x$0, y, decimals);\r\n            });\r\n        }\r\n    })();\r\n}","import { type Closure } from \"@root\";\r\nimport { type Wrapper } from \"@root\";\r\n\r\nexport namespace Ref {\r\n    export type Task<T1> = Closure<[new: T1, old: T1], void>;\r\n    \r\n    export type DeletionTask = Closure<[], void>;\r\n}\r\n\r\nexport type Ref<T1> = \r\n    & Wrapper<T1> \r\n    & {\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Mutates the internal value of the `Ref` instance.\r\n     */\r\n    mut(value: T1): Ref<T1>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Registers a callback that is invoked whenever the value changes.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let ref: Ref<bigint> = Ref(200n);\r\n     *  ref.onChange(value => {\r\n     *      /// ...\r\n     *      return;\r\n     *  });\r\n     *  ref.mut(404n);\r\n     * ```\r\n     */\r\n    onChange(task: Ref.Task<T1>): Ref.DeletionTask;\r\n};\r\n\r\n/**\r\n * ***Brief***\r\n * Wrapper that supports mutation and change tracking.\r\n */\r\nexport function Ref<T1>(_value: T1): Ref<T1> {\r\n    let _this: Ref<T1>;\r\n    let _count: bigint;\r\n    let _taskMap: Map<bigint, Ref.Task<T1>>;\r\n\r\n    /** @constructor */ {\r\n        _count = 0n;\r\n        _taskMap = new Map();\r\n        return _this = { unwrap, mut, onChange };\r\n    }\r\n\r\n    function unwrap(): T1 {\r\n        return _value;\r\n    }\r\n\r\n    function mut(value: T1): Ref<T1> {\r\n        let oldValue: T1 = unwrap();\r\n        let newValue: T1 = value;\r\n        _value = value;\r\n        _taskMap\r\n            .values()\r\n            .toArray()\r\n            .forEach(task => {\r\n                return task(newValue, oldValue);\r\n            });\r\n        return _this;\r\n    }\r\n\r\n    function onChange(task: Ref.Task<T1>): Ref.DeletionTask {\r\n        let key: bigint = _newKey();\r\n        _taskMap.set(key, task);\r\n        return () => {\r\n            _taskMap.delete(key);\r\n            return;\r\n        }\r\n    }\r\n\r\n    function _newKey(): bigint {\r\n        return _count += 1n;\r\n    }\r\n}","import { Error } from \"@root\";\r\n\r\nexport type DomError = Error<DomError.Code>;\r\n\r\nexport function DomError(): DomError;\r\nexport function DomError(_legacy: DOMException): DomError;\r\nexport function DomError(\r\n    _p0?: DOMException\r\n): DomError {\r\n    {\r\n        let e: DOMException | undefined = _p0;\r\n        if (e) return Error(_match(e), e.message);\r\n        return Error(\"DOM.ERR_UNKNOWN\");\r\n    }\r\n\r\n    function _match(e: DOMException): DomError.Code {\r\n        let code: DomError.Code = \"DOM.ERR_UNKNOWN\";\r\n        if (\r\n            e.code === 1\r\n            || e.code === 3\r\n            || e.code === 4\r\n            || e.code === 5\r\n            || e.code === 7\r\n            || e.code === 8\r\n            || e.code === 9\r\n            || e.code === 11\r\n            || e.code === 12\r\n            || e.code === 13\r\n            || e.code === 14\r\n            || e.code === 17\r\n            || e.code === 18\r\n            || e.code === 19\r\n            || e.code === 20\r\n            || e.code === 21\r\n            || e.code === 22\r\n            || e.code === 23\r\n            || e.code === 24\r\n            || e.code === 25\r\n        ) code = DomError.Exception.CodeRemap[e.code];\r\n        else if (\r\n            e.name === \"EncodingError\"\r\n            || e.name === \"NotReadableError\"\r\n            || e.name === \"UnknownError\"\r\n            || e.name === \"ConstraintError\"\r\n            || e.name === \"DataError\"\r\n            || e.name === \"TransactionInactiveError\"\r\n            || e.name === \"ReadOnlyError\"\r\n            || e.name === \"VersionError\"\r\n            || e.name === \"OperationError\"\r\n            || e.name === \"NotAllowedError\"\r\n        ) code = DomError.Exception.NameRemap[e.name];\r\n        return code;\r\n    }\r\n}\r\n\r\nexport namespace DomError {\r\n    export type Code =\r\n        | \"DOM.ERR_INDEX_SIZE\"\r\n        | \"DOM.ERR_HIERARCHY_REQUEST\"\r\n        | \"DOM.ERR_WRONG_DOCUMENT\"\r\n        | \"DOM.ERR_INVALID_CHARACTER\"\r\n        | \"DOM.ERR_NO_MODIFICATION_ALLOWED\"\r\n        | \"DOM.ERR_NOT_FOUND\"\r\n        | \"DOM.ERR_NOT_SUPPORTED\"\r\n        | \"DOM.ERR_INVALID_STATE\"\r\n        | \"DOM.ERR_ATTRIBUTE_IN_USE\"\r\n        | \"DOM.ERR_SYNTAX\"\r\n        | \"DOM.ERR_INVALID_MODIFICATION\"\r\n        | \"DOM.ERR_NAMESPACE\"\r\n        | \"DOM.ERR_INVALID_ACCESS\"\r\n        | \"DOM.ERR_TYPE_MISMATCH\"\r\n        | \"DOM.ERR_SECURITY\"\r\n        | \"DOM.ERR_NETWORK\"\r\n        | \"DOM.ERR_ABORT\"\r\n        | \"DOM.ERR_URL_MISMATCH\"\r\n        | \"DOM.ERR_QUOTA_EXCEEDED\"\r\n        | \"DOM.ERR_TIMEOUT\"\r\n        | \"DOM.ERR_INVALID_NODE_TYPE\"\r\n        | \"DOM.ERR_DATA_CLONE\"\r\n        | \"DOM.ERR_ENCODING\"\r\n        | \"DOM.ERR_NOT_READABLE\"\r\n        | \"DOM.ERR_UNKNOWN\"\r\n        | \"DOM.ERR_CONSTRAINT\"\r\n        | \"DOM.ERR_DATA\"\r\n        | \"DOM.ERR_TRANSACTION_INACTIVE\"\r\n        | \"DOM.ERR_READ_ONLY\"\r\n        | \"DOM.ERR_VERSION\"\r\n        | \"DOM.ERR_OPERATION\"\r\n        | \"DOM.ERR_NOT_ALLOWED\";\r\n\r\n    export namespace Exception {\r\n        export const NameRemap: Record<Name, DomError.Code> = {\r\n            \"EncodingError\": \"DOM.ERR_ENCODING\",\r\n            \"NotReadableError\": \"DOM.ERR_NOT_READABLE\",\r\n            \"UnknownError\": \"DOM.ERR_UNKNOWN\",\r\n            \"ConstraintError\": \"DOM.ERR_CONSTRAINT\",\r\n            \"DataError\": \"DOM.ERR_DATA\",\r\n            \"TransactionInactiveError\": \"DOM.ERR_TRANSACTION_INACTIVE\",\r\n            \"ReadOnlyError\": \"DOM.ERR_READ_ONLY\",\r\n            \"VersionError\": \"DOM.ERR_VERSION\",\r\n            \"OperationError\": \"DOM.ERR_OPERATION\",\r\n            \"NotAllowedError\": \"DOM.ERR_NOT_ALLOWED\"\r\n        };\r\n\r\n        export const CodeRemap: Record<Code, DomError.Code> = {\r\n            1: \"DOM.ERR_INDEX_SIZE\",\r\n            3: \"DOM.ERR_HIERARCHY_REQUEST\",\r\n            4: \"DOM.ERR_WRONG_DOCUMENT\",\r\n            5: \"DOM.ERR_INVALID_CHARACTER\",\r\n            7: \"DOM.ERR_NO_MODIFICATION_ALLOWED\",\r\n            8: \"DOM.ERR_NOT_FOUND\",\r\n            9: \"DOM.ERR_NOT_SUPPORTED\",\r\n            11: \"DOM.ERR_INVALID_STATE\",\r\n            12: \"DOM.ERR_SYNTAX\",\r\n            13: \"DOM.ERR_INVALID_MODIFICATION\",\r\n            14: \"DOM.ERR_NAMESPACE\",\r\n            17: \"DOM.ERR_TYPE_MISMATCH\",\r\n            18: \"DOM.ERR_SECURITY\",\r\n            19: \"DOM.ERR_NETWORK\",\r\n            20: \"DOM.ERR_ABORT\",\r\n            21: \"DOM.ERR_URL_MISMATCH\",\r\n            22: \"DOM.ERR_QUOTA_EXCEEDED\",\r\n            23: \"DOM.ERR_TIMEOUT\",\r\n            24: \"DOM.ERR_INVALID_NODE_TYPE\",\r\n            25: \"DOM.ERR_DATA_CLONE\"\r\n        };\r\n\r\n        export type Name =\r\n            | \"EncodingError\"\r\n            | \"NotReadableError\"\r\n            | \"UnknownError\"\r\n            | \"ConstraintError\"\r\n            | \"DataError\"\r\n            | \"TransactionInactiveError\"\r\n            | \"ReadOnlyError\"\r\n            | \"VersionError\"\r\n            | \"OperationError\"\r\n            | \"NotAllowedError\";\r\n\r\n        export type Code =\r\n            | 1\r\n            | 3\r\n            | 4\r\n            | 5\r\n            | 7\r\n            | 8\r\n            | 9\r\n            | 11\r\n            | 12\r\n            | 13\r\n            | 14\r\n            | 17\r\n            | 18\r\n            | 19\r\n            | 20\r\n            | 21\r\n            | 22\r\n            | 23\r\n            | 24\r\n            | 25;\r\n    }\r\n}","import { type AsyncClosure } from \"@root\";\r\nimport { type Closure } from \"@root\";\r\nimport { type Function as Function0 } from \"@root\";\r\nimport { type Wrapper } from \"@root\";\r\nimport { type RecoveryWrapper } from \"@root\";\r\nimport { type Branded } from \"@root\";\r\nimport { BrandedStruct } from \"@root\";\r\nimport { Unsafe } from \"@root\";\r\n\r\ntype Array$0<T1> = Array<T1>;\r\n\r\nexport type Error<T1 extends string, T2 = unknown> = \r\n    & BrandedStruct<\"Error\">\r\n    & {\r\n\r\n    /**\r\n     * ***Brief***\r\n     * The unique identifier for this error.\r\n     */\r\n    code: T1;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * A human-readable message that explains the nature of the error.\r\n     */\r\n    message: Option<string>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * An optional value that can hold additional data or context related to the error.\r\n     */\r\n    payload: Option<T2>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * The stack trace associated with the error.\r\n     */\r\n    stack: string;\r\n};\r\n\r\n/**\r\n * ***Brief***\r\n * A custom error with an optional message and payload for strongly-typed errors.\r\n * \r\n * ***Note***\r\n * This is a general-purpose error structure to manage domain-specific error codes and provide better context.\r\n */\r\nexport function Error<T1 extends string, T2 = unknown>(_configuration: Error.Configuration<T1, T2>): Error<T1, T2>;\r\nexport function Error<T1 extends string, T2 = unknown>(_code: T1, _message?: string, _payload?: T2): Error<T1, T2>;\r\nexport function Error<T1 extends string, T2 = unknown>(\r\n    _p0: Error.Configuration<T1, T2> | T1,\r\n    _p1?: string,\r\n    _p2?: T2\r\n): Error<T1, T2> {\r\n    /** @constructor */ {\r\n        if (typeof _p0 === \"object\") {\r\n            let configuration: Error.Configuration<T1, T2> = _p0;\r\n            let handler: Error.Handler = flag(configuration.handler).unwrapOr(Error.Handler);\r\n            return {\r\n                type: \"Error\",\r\n                code: configuration.code,\r\n                message: Option.Handler.flag(configuration.message),\r\n                payload: Option.Handler.flag(configuration.payload),\r\n                stack: Option.Handler.flag(configuration.stack).unwrapOr(handler.localStackTrace(Error).unwrapOr(\"\"))\r\n            };\r\n        }\r\n        return {\r\n            type: \"Error\",\r\n            code: _p0,\r\n            message: Option.Handler.flag(_p1),\r\n            payload: Option.Handler.flag(_p2),\r\n            stack: Error.Handler.localStackTrace(Error).unwrapOr(\"\")\r\n        };\r\n    }\r\n}\r\n\r\nexport namespace Error {\r\n    export type Configuration<T1 extends string, T2 = unknown> = {\r\n        code: T1;\r\n        message?: string;\r\n        payload?: T2;\r\n        stack?: string;\r\n        handler?: Error.Handler;\r\n    };\r\n\r\n    export type Task<T1 extends string, T2 = unknown> = Closure<[e: Error<T1, T2>], void>;\r\n\r\n    export type Handler = {\r\n        match(unknown: unknown): unknown is Error<any, unknown>;\r\n        match(unknown: unknown, task: Task<any>): unknown is Error<any, unknown>;\r\n        match<T1 extends string>(unknown: unknown, code: T1): unknown is Error<T1, unknown>;\r\n        match<T1 extends string>(unknown: unknown, code: T1, task: Task<T1>): unknown is Error<T1, unknown>;\r\n\r\n        /**\r\n         * ***Brief***\r\n         * `panic` throws an error with optional message and stack trace location.\r\n         * \r\n         * ***Example***\r\n         * ```ts\r\n         *  panic(Error(\"MATH.ERR_DIVISION_BY_ZERO\"));\r\n         *  panic(Error({\r\n         *      code: \"MATH.ERR_DIVISION_BY_ZERO\",\r\n         *      message: Some(\"Math: Cannot divide by zero.\"),\r\n         *      payload: None,\r\n         *      stack: StackTrace(...)\r\n         *  }));\r\n         *  panic(\"An unrecoverable error has occured.\");\r\n         * ```\r\n         */\r\n        panic<T1 extends string>(e: Error<T1>, handler?: Handler): never;\r\n        panic<T1 extends string>(code: T1, at?: Function, handler?: Handler): never;\r\n        localStackTrace(at: Function): Option<string>;\r\n    };\r\n\r\n    export const Handler: Handler = (() => {\r\n        let _this: Handler;\r\n\r\n        /** @constructor */ {\r\n            return _this = { match, panic, localStackTrace };\r\n        }\r\n\r\n        function match(unknown: unknown): unknown is Error<any, unknown>;\r\n        function match(unknown: unknown, task: Task<any>): unknown is Error<any, unknown>;\r\n        function match<T1 extends string>(unknown: unknown, code: T1): unknown is Error<T1, unknown>;\r\n        function match<T1 extends string>(unknown: unknown, code: T1, task: Task<T1>): unknown is Error<T1, unknown>;\r\n        function match<T1 extends string>(\r\n            p0: unknown,\r\n            p1?: T1 | Closure<[e: Error<T1, unknown>], void>,\r\n            p2?: Closure<[e: Error<T1, unknown>], void>\r\n        ): p0 is Error<T1, unknown> {\r\n            let unknown: unknown = p0;\r\n            if (!BrandedStruct.Handler.match(unknown)) return false;\r\n            if (typeof p1 === \"string\") {\r\n                let code: T1 = p1;\r\n                if (!BrandedStruct.Handler.match(unknown, code)) return false;\r\n            }\r\n            let value: Error<T1> = (unknown as Error<T1>);\r\n            if (typeof p1 === \"function\") {\r\n                let task: Task<T1> = p1;\r\n                task(value);\r\n                return true;\r\n            }\r\n            if (typeof p2 === \"function\") {\r\n                let task: Task<T1> = p2;\r\n                task(value);\r\n                return true;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        function panic<T1 extends string>(e: Error<T1>, handler?: Handler): never;\r\n        function panic<T1 extends string>(code: T1, at?: Function, handler?: Handler): never;\r\n        function panic<T1 extends string>(\r\n            p0: Error<T1> | T1,\r\n            p1?: Handler | Function,\r\n            p2?: Handler\r\n        ): never {\r\n            if (typeof p0 === \"object\") {\r\n                let e: Error<T1> = p0;\r\n                let shards: Array$0<string> = e.stack.split(\"\\n\");\r\n                shards.shift();\r\n                e.stack = shards.join(\"\\n\");\r\n                console.log(shards, \"ff\");\r\n                throw \"\\x1Bc\" + `\\x1B[31m${ e.code }: ${ e.message.unwrapOr(\"\") }\\x1B[0m` + \"\\n\" + `${ e.stack }`;\r\n            }\r\n            let code: T1 = p0;\r\n            let at: Function = flag((p1 as Function | undefined)).unwrapOr(panic);\r\n            let handler: Handler = flag(p2).unwrapOr(_this);\r\n            let stack: string = handler\r\n                .localStackTrace(at)\r\n                .toResult(None)\r\n                .map(stack => {\r\n                    let shards: Array$0<string> = stack.split(\"\\n\");\r\n                    shards.shift();\r\n                    return shards.join(\"\\n\");\r\n                })\r\n                .recover(() => {\r\n                    return \"<<< 404 >>>\";\r\n                })\r\n                .unwrap();\r\n                \r\n            throw \"\\x1Bc\" + `\\x1B[31m${ code }\\x1B[0m` + \"\\n\" + `${ stack }`;\r\n        }\r\n\r\n        function localStackTrace(location: Function): Option<string> {\r\n            let e: ReturnType<typeof globalThis.Error> = globalThis.Error();\r\n            globalThis.Error.captureStackTrace(e, location);\r\n            if (e.stack) return Some(e.stack);\r\n            return None;\r\n        }\r\n    })();\r\n}\r\n\r\n/**\r\n * ***Brief***\r\n * A wrapper that encapsulates either a successful outcome `Ok<T1>` or a failure `Err<T2>`.\r\n * \r\n * ***Example***\r\n * ```ts\r\n *  function foo(): Result<200n, 404n> {\r\n *      if () return Ok(200n);\r\n *      return Err(404n);\r\n *  }\r\n * \r\n *  let result: Result<200n, 404n> = foo();\r\n *  if (result.ok()) {\r\n *      let value: 200n = result.unlock();\r\n *      /// ...\r\n *  }\r\n * ```\r\n */\r\nexport type Result<T1, T2> = Ok<T1> | Err<T2>;\r\n\r\nexport namespace Result {\r\n    export type Async<T1, T2> = Promise<Result<T1, T2>>;\r\n\r\n    export type Array<T1, T2> = Array$0<Result<T1, T2>>;\r\n\r\n    export type Handler = {\r\n        /**\r\n         * ***Brief***\r\n         * Iterates through an array of `Result`, short-circuiting at the first `Err`.\r\n         * \r\n         * ***Example***\r\n         * ```ts\r\n         * let r0: Result<200n, 404n>;\r\n         * let r1: Result<201n, 405n>;\r\n         * let r2: Result<202n, 406n>;\r\n         * let r: Result<[200n, 201n, 202n], 404n | 405n | 406n> = Result.all([r0, r1, r2]);\r\n         * ```\r\n         */\r\n        all<T1 extends Array<unknown, unknown>>(results: T1): Result<Ok.ValFromAll<T1>, Err.ValFromAll<T1>[number]>;\r\n        \r\n        /**\r\n         * ***Brief***\r\n         * Iterates through an array of `Result`, short-circuiting at the first `Ok`.\r\n         * \r\n         * ***Example***\r\n         * ```ts\r\n         *  let r0: Result<200n, 404n>;\r\n         *  let r1: Result<201n, 405n>;\r\n         *  let r2: Result<202n, 406n>;\r\n         *  let r: Result<200n | 201n | 202n, [404n, 405n, 406n]> = Result.any([r0, r1, r2]);\r\n         * ```\r\n         */\r\n        any<T1 extends Array<unknown, unknown>>(results: T1): Result<Ok.ValFromAll<T1>[number], Err.ValFromAll<T1>>;\r\n        \r\n        /**\r\n         * ***Brief***\r\n         * Wraps an unsafe operation that might throw an error and returns a `Result`.\r\n         * \r\n         * ***Example***\r\n         * ```ts\r\n         *  await Result.wrap(() => {\r\n         *      /// Some unsafe task.\r\n         *      /// ...\r\n         *      return 200n;\r\n         *  }).mapErr(unsafe => {\r\n         *      unsafe\r\n         *          .parse((unknown): unknown is string => {\r\n         *              return typeof unknown is \"string\";\r\n         *          })\r\n         *          .map(string => {\r\n         *              /// ...\r\n         *          });\r\n         *      return 200n;\r\n         *  });\r\n         * ```\r\n         */\r\n        wrap<T1, T2, T3 extends Array$0<T2>>(task: Closure<T3, T1>, ...payload: T3): Result<T1, Unsafe>;\r\n        \r\n        /**\r\n         * ***Brief***\r\n         * Wraps an asynchronous unsafe operation that may throw and returns a `Result`.\r\n         * \r\n         * \r\n         * ***Example***\r\n         * ```ts\r\n         *  await Result.wrapAsync(async () => {\r\n         *      /// Some unsafe async task.\r\n         *      /// ...\r\n         *      return 200n;\r\n         *  }).mapErr(unsafe => {\r\n         *      unsafe\r\n         *          .parse((unknown): unknown is string => {\r\n         *              return typeof unknown is \"string\";\r\n         *          })\r\n         *          .map(string => {\r\n         *              /// ...\r\n         *          });\r\n         *      return 200n;\r\n         *  });\r\n         * ```\r\n         */\r\n        wrapAsync<T1, T2, T3 extends Array$0<T2>>(task: AsyncClosure<T3, T1>, ...payload: T3): Promise<Result<T1, Unsafe>>;\r\n    };\r\n\r\n    export const Handler: Handler = (() => {\r\n        /** @constructor */ {\r\n            return { all, any, wrap, wrapAsync };\r\n        }\r\n\r\n        function all<T1 extends Array<unknown, unknown>>(results: T1): Result<Ok.ValFromAll<T1>, Err.ValFromAll<T1>[number]> {\r\n            let out: Array$0<unknown> = [];\r\n            let i: number = 0;\r\n            while (i < results.length) {\r\n                let result: Result<unknown, unknown> = results.at(i)!;\r\n                if (result.ok()) out.push(result.unwrap());\r\n                else return result as Err<Err.ValFromAll<T1>[number]>;\r\n                i ++;\r\n            }\r\n            return Ok((out as Ok.ValFromAll<T1>));\r\n        }\r\n    \r\n        function any<T1 extends Array<unknown, unknown>>(results: T1): Result<Ok.ValFromAll<T1>[number], Err.ValFromAll<T1>> {\r\n            let out: Array$0<unknown> = [];\r\n            let i: number = 0;\r\n            while (i < results.length) {\r\n                let wrapper: Result<unknown, unknown> = results.at(i)!;\r\n                if (wrapper.ok()) return wrapper as Ok<Ok.ValFromAll<T1>[number]>;\r\n                else out.push(wrapper.inspect());\r\n                i ++;\r\n            }\r\n            return Err((out as Err.ValFromAll<T1>));\r\n        }\r\n        \r\n        function wrap<T1, T2, T3 extends Array$0<T2>>(task: Closure<T3, T1>, ...payload: T3): Result<T1, Unsafe> {\r\n            try {\r\n                return Ok(task(...payload));\r\n            }\r\n            catch (e) {\r\n                return Err(Unsafe(e));\r\n            }\r\n        }\r\n    \r\n        async function wrapAsync<T1, T2, T3 extends Array$0<T2>>(task: AsyncClosure<T3, T1>, ...payload: T3): Promise<Result<T1, Unsafe>> {\r\n            try {\r\n                return Ok((await task(...payload)));\r\n            }\r\n            catch (e) {\r\n                return Err(Unsafe(e));\r\n            }\r\n        }\r\n    })();\r\n}\r\n\r\nexport type Ok<T1> = \r\n    & Wrapper<T1>\r\n    & {\r\n\r\n    /**\r\n     * ***Brief***\r\n     * `ok` checks if the current instance is `Ok`.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n>;\r\n     *  if (result.ok()) {\r\n     *      let value: 200n = result.unlock();\r\n     *      /// ...\r\n     *  }\r\n     * ```\r\n     */\r\n    ok(): this is Ok<T1>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * `err` checks if the current instance is `Err`.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n>;\r\n     *  if (result.err()) {\r\n     *      let e: 404n = result.inspect();\r\n     *      /// ...\r\n     *  }\r\n     * ```\r\n     */\r\n    err(): this is Err<unknown>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * `expect` terminates with `panic` if the `Result` is `Err`.\r\n     * \r\n     * ***Warning***\r\n     * Reserved for debugging or unrecoverable errors.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n>;\r\n     *  let status: 200n = result.expect(\"This is unexpected and unrecoverable.\");\r\n     * ```\r\n     */\r\n    expect(): T1;\r\n    expect(__: unknown): T1;\r\n    expect(__?: unknown): T1;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Ensures that the `Result` is an `Err` and retrieves the error value inside.\r\n     * \r\n     * ***Warning***\r\n     * Reserved for debugging or unrecoverable errors.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n>;\r\n     *  let status: 404n = result.expectErr(\"This is unexpected and unrecoverable.\");\r\n     * ```\r\n    */\r\n    expectErr(): never;\r\n    expectErr(message: string): never;\r\n    expectErr(message?: string): never;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Retrieves the value of an `Ok`, or falls back to the provided value if its an `Err`.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n> = Err(404n);\r\n     *  let status: 200n = result.unwrapOr(200n);\r\n     *  console.log(status); /// 200n.\r\n     * ```\r\n     */\r\n    unwrapOr(__: unknown): T1;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Recovers from the current error by applying a recovery function, transforming the `Err` into an `Ok`.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n> = Err(404n);\r\n     *  let status: 200n = result\r\n     *      .recover(() => {\r\n     *          return 200n;\r\n     *      })\r\n     *      .unlock();\r\n     * ```\r\n     */\r\n    recover(__: unknown): Ok<T1>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Applies a transformation to the `Ok` value and returns an `Err` instance with the transformed value.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n> = Ok(200n);\r\n     *  let e: 404n = result\r\n     *      .degrade(() => {\r\n     *          return 404n;\r\n     *      })\r\n     *      .inspect();\r\n     *  console.log(e); /// 404n.\r\n     * ```\r\n     */\r\n    degrade<T2>(task: Function0<T1, T2>): Err<T2>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Chains an task until the first `Err` is encountered.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n> = Err(404n);\r\n     *  result\r\n     *      .and(value => {\r\n     *          /// Task is skipped because `Result` is an `Err`.\r\n     *          /// ...\r\n     *          return Ok(value + 1n);\r\n     *      })\r\n     *      .and(value => {\r\n     *          /// Task is skipped because `Result` is an `Err`.\r\n     *          /// ...\r\n     *      });\r\n     * ```\r\n     */\r\n    and<T2>(task: Closure<[T1], Ok<T2>>): Ok<T2>;\r\n    and<T2>(task: Closure<[T1], Err<T2>>): Result<T1, T2>;\r\n    and<T2, T3>(task: Closure<[T1], Result<T2, T3>>): Result<T2, T3>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Transforms the `Ok` value if present, but if this is already an `Err`, it remains unchanged.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result0: Result<200n, 404n> = Ok(200n);\r\n     *  let result1: Result<201n, 404n> = result.map(value => {\r\n     *      /// Task is run because `Result` is `Ok`.\r\n     *      /// ...\r\n     *      return value + 1n;\r\n     *  });\r\n     * ```\r\n     */\r\n    map<T2>(task: Closure<[T1], T2>): Ok<T2>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Transforms the error contained in the `Err` using the provided `task` function.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n> = Err(404n);\r\n     *  result\r\n     *      .mapErr(e => {\r\n     *          return e + 1n;\r\n     *      })\r\n     *      .inspect(); /// 405n.\r\n     * ```\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n> = Ok(200n);\r\n     *  result\r\n     *      .mapErr(e => {\r\n     *          /// Task is run because `Result` is `Ok`.\r\n     *          /// ...\r\n     *      });\r\n     * ```\r\n     */\r\n    mapErr(__: unknown): Ok<T1>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Converts a `Result<T1, T2>` to an `Option<T1>`.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n>;\r\n     *  let option: Option<200n> = result.toOption();\r\n     * ```\r\n     */\r\n    toOption(): Option<T1>;\r\n};\r\n\r\n/**\r\n * ***Brief***\r\n * The successful value within a `Result`.\r\n */\r\nexport function Ok<T1>(_value: T1): Ok<T1> {\r\n    let _this: Ok<T1>;\r\n\r\n    /** @constructor */ {\r\n        return _this = {\r\n            ok,\r\n            err,\r\n            expect,\r\n            expectErr,\r\n            unwrap,\r\n            unwrapOr,\r\n            and,\r\n            map,\r\n            mapErr,\r\n            recover,\r\n            degrade,\r\n            toOption\r\n        };\r\n    }\r\n\r\n    function ok(): this is Ok<T1> {\r\n        return true;\r\n    }\r\n\r\n    function err(): this is Err<unknown> {\r\n        return false;\r\n    }\r\n    \r\n    function expect(): T1;\r\n    function expect(__: unknown): T1;\r\n    function expect(__?: unknown): T1 {\r\n        return unwrap();\r\n    }\r\n\r\n    function expectErr(): never;\r\n    function expectErr(message: string): never;\r\n    function expectErr(message?: string): never {\r\n        Error.Handler.panic(Error(\"PANIC\", message));\r\n    }\r\n\r\n    function unwrap(): T1 {\r\n        return _value;\r\n    }\r\n\r\n    function unwrapOr(__: unknown): T1 {\r\n        return unwrap();\r\n    }\r\n\r\n    function and<T2>(task: Closure<[T1], Ok<T2>>): Ok<T2>;\r\n    function and<T2>(task: Closure<[T1], Err<T2>>): Result<T1, T2>;\r\n    function and<T2, T3>(task: Closure<[T1], Result<T2, T3>>): Result<T2, T3>;\r\n    function and<T2, T3>(task: Closure<[T1], Result<T2, T3>>): Result<T2, T3> {\r\n        return task(unwrap());\r\n    }\r\n\r\n    function map<T2>(task: Closure<[T1], T2>): Ok<T2> {\r\n        return Ok(task(unwrap()));\r\n    }\r\n\r\n    function mapErr(__: unknown): Ok<T1> {\r\n        return _this;\r\n    }\r\n\r\n    function recover(__: unknown): Ok<T1> {\r\n        return _this;\r\n    }\r\n\r\n    function degrade<T2>(task: Closure<[T1], T2>): Err<T2> {\r\n        return Err(task(unwrap()));\r\n    }\r\n\r\n    function toOption(): Option<T1> {\r\n        return Some(unwrap());\r\n    }\r\n}\r\n\r\nexport namespace Ok {\r\n    export type From<T1 extends Result<unknown, unknown>> = T1 extends Ok<infer T2> ? Ok<T2> : never;\r\n\r\n    export type FromAll<T1 extends Array<Result<unknown, unknown>>> = {\r\n        [T2 in keyof T1]: T1[T2] extends Ok<unknown> ? From<T1[T2]> : never;\r\n    };\r\n\r\n    export type ValFrom<T1 extends Result<unknown, unknown>> = T1 extends Ok<infer T2> ? T2 : never;\r\n\r\n    export type ValFromAll<T1 extends Array<Result<unknown, unknown>>> = {\r\n        [T2 in keyof T1]: ValFrom<T1[T2]>;\r\n    };\r\n}\r\n\r\nexport type Err<T1> = \r\n    & RecoveryWrapper<T1>\r\n    & {\r\n\r\n    /**\r\n     * ***Brief***\r\n     * `ok` checks if the current instance is `Ok`.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n>;\r\n     *  if (result.ok()) {\r\n     *      let value: 200n = result.unlock();\r\n     *      /// ...\r\n     *  }\r\n     * ```\r\n     */\r\n    ok(): this is Ok<unknown>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * `err` checks if the current instance is `Err`.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n>;\r\n     *  if (result.err()) {\r\n     *      let e: 404n = result.inspect();\r\n     *      /// ...\r\n     *  }\r\n     * ```\r\n     */\r\n    err(): this is Err<T1>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Retrieves the error value encapsulated by the `Err` instance.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n>;\r\n     *  if (result.err()) {\r\n     *      let e: 404n = result.inspect();\r\n     *      /// ...\r\n     *  }\r\n     * ```\r\n     */\r\n    inspect(): T1;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Retrieves the stack trace of the error, generated at the time the `Err` instance was created.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n>;\r\n     *  if (result.err()) {\r\n     *      result\r\n     *          .stack()\r\n     *          .lines()\r\n     *          .forEach(line => {\r\n     *              let lineRepresentation: string = line.toString();\r\n     *              /// ...\r\n     *              return; \r\n     *          });\r\n     *  }\r\n     * ```\r\n     */\r\n    stack(): string;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * `expect` terminates with `panic` if the `Result` is `Err`.\r\n     * \r\n     * ***Warning***\r\n     * Reserved for debugging or unrecoverable errors.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n>;\r\n     *  let status: 200n = result.expect(\"This is unexpected and unrecoverable.\");\r\n     * ```\r\n     */\r\n    expect(): never;\r\n    expect(message: string): never;\r\n    expect(message?: string): never;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Ensures that the `Result` is an `Err` and retrieves the error value inside.\r\n     * \r\n     * ***Warning***\r\n     * Reserved for debugging or unrecoverable errors.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n>;\r\n     *  let status: 404n = result.expectErr(\"This is unexpected and unrecoverable.\");\r\n     * ```\r\n    */\r\n    expectErr(): T1;\r\n    expectErr(__: unknown): T1;\r\n    expectErr(__?: unknown): T1;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Retrieves the value of an `Ok`, or falls back to the provided value if its an `Err`.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n> = Err(404n);\r\n     *  let status: 200n = result.unwrapOr(200n);\r\n     *  console.log(status); /// 200n.\r\n     * ```\r\n     */\r\n    unwrapOr<T2>(fallback: T2): T2;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Chains an task until the first `Err` is encountered.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n> = Err(404n);\r\n     *  result\r\n     *      .and(value => {\r\n     *          /// Task is skipped because `Result` is an `Err`.\r\n     *          /// ...\r\n     *          return Ok(value + 1n);\r\n     *      })\r\n     *      .and(value => {\r\n     *          /// Task is skipped because `Result` is an `Err`.\r\n     *          /// ...\r\n     *      });\r\n     * ```\r\n     */\r\n    and(__: unknown): Err<T1>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Transforms the `Ok` value if present, but if this is already an `Err`, it remains unchanged.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result0: Result<200n, 404n> = Ok(200n);\r\n     *  let result1: Result<201n, 404n> = result.map(value => {\r\n     *      /// Task is run because `Result` is `Ok`.\r\n     *      /// ...\r\n     *      return value + 1n;\r\n     *  });\r\n     * ```\r\n     */\r\n    map(__: unknown): Err<T1>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Transforms the error contained in the `Err` using the provided `task` function.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n> = Err(404n);\r\n     *  result\r\n     *      .mapErr(e => {\r\n     *          return e + 1n;\r\n     *      })\r\n     *      .inspect(); /// 405n.\r\n     * ```\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n> = Ok(200n);\r\n     *  result\r\n     *      .mapErr(e => {\r\n     *          /// Task is run because `Result` is `Ok`.\r\n     *          /// ...\r\n     *      });\r\n     * ```\r\n     */\r\n    mapErr<T2>(task: Closure<[T1], T2>): Err<T2>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Recovers from the current error by applying a recovery function, transforming the `Err` into an `Ok`.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n> = Err(404n);\r\n     *  let status: 200n = result\r\n     *      .recover(() => {\r\n     *          return 200n;\r\n     *      })\r\n     *      .unlock();\r\n     * ```\r\n     */\r\n    recover<T2>(task: Closure<[T1], T2>): Ok<T2>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Applies a transformation to the `Ok` value and returns an `Err` instance with the transformed value.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n> = Ok(200n);\r\n     *  let e: 404n = result\r\n     *      .degrade(() => {\r\n     *          return 404n;\r\n     *      })\r\n     *      .inspect();\r\n     *  console.log(e); /// 404n.\r\n     * ```\r\n     */\r\n    degrade(__: unknown): Err<T1>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Converts a `Result<T1, T2>` to an `Option<T1>`.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let result: Result<200n, 404n>;\r\n     *  let option: Option<200n> = result.toOption();\r\n     * ```\r\n     */\r\n    toOption(): Option<never>;\r\n};\r\n\r\n/**\r\n * ***Brief***\r\n * The failed state of a `Result`.\r\n * \r\n * ***Warning***\r\n * Any operation attempting to access a `Result` must safely handle the `Err` state or terminate with an error.\r\n */\r\nexport function Err<T1>(_value: T1): Err<T1>;\r\nexport function Err<T1>(_value: T1, _handler: Error.Handler): Err<T1>;\r\nexport function Err<T1>(\r\n    _p0: T1,\r\n    _p1?: Error.Handler\r\n): Err<T1> {\r\n    let _this: Err<T1>;\r\n    let _stack: string;\r\n    let _value: T1;\r\n    let _handler: Error.Handler;\r\n    \r\n    /** @constructor */ {\r\n        _value = _p0;\r\n        _handler = _p1 ?? Error.Handler;\r\n        _stack = _handler.localStackTrace(Err).unwrapOr(\"\");\r\n        return _this = {\r\n            ok,\r\n            err,\r\n            inspect,\r\n            stack,\r\n            expect,\r\n            expectErr,\r\n            unwrapOr,\r\n            and,\r\n            map,\r\n            mapErr,\r\n            recover,\r\n            degrade,\r\n            toOption\r\n        };\r\n    }\r\n\r\n    function ok(): this is Ok<unknown> {\r\n        return false;\r\n    }\r\n\r\n    function err(): this is Err<T1> {\r\n        return true;\r\n    }\r\n\r\n    function inspect(): T1 {\r\n        return _value;\r\n    }\r\n\r\n    function stack(): string {\r\n        return _stack;\r\n    }\r\n\r\n    function expect(): never;\r\n    function expect(message: string): never;\r\n    function expect(message?: string): never {\r\n        let e: T1 = inspect();\r\n        if (typeof e === \"string\") {\r\n            if (e.includes(\".\")) {\r\n                if (\r\n                    e.split(\".\")\r\n                        ?.at(1)\r\n                        ?.startsWith(\"ERR\")\r\n                ) Error.Handler.panic(e, expect);\r\n            }\r\n            else {\r\n                if (e.startsWith(\"ERR\")) Error.Handler.panic(e, expect);\r\n            }\r\n        }\r\n        if (typeof e === \"string\") {\r\n            if (\r\n                e.includes(\".\")\r\n                && e.split(\".\")\r\n                    ?.at(1)\r\n                    ?.startsWith(\"ERR\")\r\n            ) Error.Handler.panic(e, expect);\r\n        }\r\n        if (e instanceof globalThis.Error) {\r\n            let code: string = e.name;\r\n            let message$0: string = `${ e.message } ${ message ? `${ message }` : \"\" }`;\r\n            let stack$0: string = e.stack ?? stack();\r\n            Error.Handler.panic(Error({\r\n                code: code,\r\n                message: message$0,\r\n                stack: stack$0\r\n            }));\r\n        }\r\n        Error.Handler.match(inspect(), e => {\r\n            Error.Handler.panic(Error({\r\n                code: e.code,\r\n                message: `${ e.message } ${ message ? `${ message }` : \"\" }`,\r\n                stack: e.stack\r\n            }))\r\n        });\r\n        Error.Handler.panic(Error({\r\n            code: \"PANIC\",\r\n            message: `${ message ? message : \"An unrecoverable error has caused the program to panic.\"}`,\r\n            stack: Error.Handler.localStackTrace(expect).unwrapOr(\"\")\r\n        }));\r\n    }\r\n\r\n    function expectErr(): T1;\r\n    function expectErr(__: unknown): T1;\r\n    function expectErr(__?: unknown): T1 {\r\n        return inspect();\r\n    }\r\n\r\n    function unwrapOr<T2>(fallback: T2): T2 {\r\n        return fallback;\r\n    }\r\n\r\n    function and(__: unknown): Err<T1> {\r\n        return _this;\r\n    }\r\n\r\n    function map(__: unknown): Err<T1> {\r\n        return _this;\r\n    }\r\n\r\n    function mapErr<T2>(task: Closure<[T1], T2>): Err<T2> {\r\n        return Err(task(inspect()));\r\n    }\r\n\r\n    function recover<T2>(task: Closure<[T1], T2>): Ok<T2> {\r\n        return Ok(task(inspect()));\r\n    }\r\n\r\n    function degrade(__: unknown): Err<T1> {\r\n        return _this;\r\n    }\r\n\r\n    function toOption(): Option<never> {\r\n        return None;\r\n    }\r\n}\r\n\r\nexport namespace Err {\r\n    export type From<T1 extends Result<unknown, unknown>> = T1 extends Err<infer T2> ? Err<T2> : never;\r\n\r\n    export type FromAll<T1 extends Array<Result<unknown, unknown>>> = {\r\n        [T2 in keyof T1]: T1[T2] extends Err<unknown> ? From<T1[T2]> : never\r\n    };\r\n\r\n    export type ValFrom<T1 extends Result<unknown, unknown>> = T1 extends Err<infer T2> ? T2 : never;\r\n\r\n    export type ValFromAll<T1 extends Array<Result<unknown, unknown>>> = {\r\n        [T2 in keyof T1]: ValFrom<T1[T2]>;\r\n    };\r\n}\r\n\r\n/**\r\n * ***Brief***\r\n * A type that represents an optional value, encapsulating either a value `Some` \r\n * or the absence of a value `None`.\r\n */\r\nexport type Option<T1> = Some<T1> | None;\r\n\r\nexport namespace Option {\r\n    export type Async<T1> = Promise<Option<T1>>;\r\n\r\n    export type Array<T1> = Array$0<Option<T1>>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Utility class for handling tasks within `Option`.\r\n     */\r\n    export type Handler = {\r\n        /**\r\n         * ***Brief***\r\n         * Wraps a value into an `Option`, turning `null` or `undefined` to `None`.\r\n         * \r\n         * ***Example***\r\n         * ```ts\r\n         *  let foo: string | undefined;\r\n         *  Option\r\n         *      .flag(foo)\r\n         *      .map(foo => {\r\n         *          /// ...\r\n         *      });\r\n         * ```\r\n         */\r\n        flag<T1>(value: T1 | null | undefined): Option<T1>;\r\n\r\n        /**\r\n         * ***Brief***\r\n         * Iterates through an array of `Option`, short-circuiting at the first `None`.\r\n         * \r\n         * ***Example***\r\n         * ```ts\r\n         *  let o0: Option<200n>;\r\n         *  let o1: Option<201n>;\r\n         *  let o2: Option<202n>;\r\n         *  let o: Option<[200n, 201n, 202n]> = Option.all([o0, o1, o2]);\r\n         * ```\r\n         */\r\n        all<T1 extends Option.Array<unknown>>(...options: T1): Option<Some.ValFromAll<T1>>;\r\n        \r\n        /**\r\n         * ***Brief***\r\n         * Iterates through an array of `Option`, short-circuiting at the first `Some`.\r\n         * \r\n         * ***Example***\r\n         * ```ts\r\n         *  let o0: Option<200n>;\r\n         *  let o1: Option<201n>;\r\n         *  let o2: Option<202n>;\r\n         *  let o: Option<200n | 201n | 202n> = Option.any([o0, o1, o2]);\r\n         * ```\r\n         */\r\n        any<T1 extends Option.Array<unknown>>(...options: T1): Option<Some.ValFromAll<T1>[number]>;\r\n    };\r\n\r\n    export const Handler: Handler = (() => {\r\n        { return { flag, all, any }; }\r\n\r\n        function flag<T1>(value: T1 | null | undefined): Option<T1> {\r\n            if (value === null) return None;\r\n            if (value === undefined) return None;\r\n            return Some((value as T1));\r\n        }\r\n\r\n        function all<T1 extends Option.Array<unknown>>(...options: T1): Option<Some.ValFromAll<T1>> {\r\n            let out: Array$0<unknown> = [];\r\n            let i: number = 0;\r\n            while (i < options.length) {\r\n                let option: Option<unknown> = options.at(i)!;\r\n                if (option.none()) return option as None;\r\n                out.push(option.unwrap());\r\n                i ++;\r\n            }\r\n            return Some(out as Some.ValFromAll<T1>);\r\n        }\r\n\r\n        function any<T1 extends Option.Array<unknown>>(...options: T1): Option<Some.ValFromAll<T1>[number]> {\r\n            let i: number = 0;\r\n            while (i < options.length) {\r\n                let option: Option<unknown> = options.at(i)!;\r\n                if (option.some()) return option as Some<Some.ValFromAll<T1>[number]>;\r\n                i ++;\r\n            }\r\n            return None;\r\n        }\r\n    })();\r\n}\r\n\r\nexport type Some<T1> = \r\n    & Branded<\"Some\">\r\n    & Wrapper<T1>\r\n    & {\r\n\r\n    /**\r\n     * ***Brief***\r\n     * `some` checks if the current instance is `Some`.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let option: Option<200n>;\r\n     *  if (option.some()) {\r\n     *      let value: 200n = option.unlock();\r\n     *      /// ...\r\n     *  }\r\n     * ```\r\n     */\r\n    some(): this is Some<T1>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * `none` checks if the current instance is `None`.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let option: Option<200n>;\r\n     *  if (option.none()) {\r\n     *      /// `Option` cannot `unlock` because it is `None`.\r\n     *      /// ...\r\n     *  }\r\n     * ```\r\n     */\r\n    none(): this is None;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * `expect` terminates with `panic` if the `Option` is `None`.\r\n     * \r\n     * ***Warning***\r\n     * Reserved for debugging or unrecoverable errors.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let option: Option<200n>;\r\n     *  let status: 200n = option.expect(\"This is unexpected and unrecoverable.\");\r\n     * ```\r\n     */\r\n    expect(): T1;\r\n    expect(__: unknown): T1;\r\n    expect(__?: unknown): T1;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Retrieves the value of a `Some`, or falls back to the provided value if its `None`.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let option: Option<200n> = None;\r\n     *  let status: 200n = option.unwrapOr(200n);\r\n     *  console.log(status); /// 200n.\r\n     * ```\r\n     */\r\n    unwrapOr(__: unknown): T1;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Chains an task until the first `None` is encountered.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let option: Option<200n> = None;\r\n     *  option\r\n     *      .and(value => {\r\n     *          /// Task is skipped because `Option` is `None`.\r\n     *          /// ...\r\n     *          return Some(value + 1n);\r\n     *      })\r\n     *      .and(value => {\r\n     *          /// Task is skipped because `Option` is `None`.\r\n     *          /// ...\r\n     *      });\r\n     * ```\r\n     */\r\n    and<T2>(task: Closure<[T1], Option<T2>>): Option<T2>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Transforms the `Some` value if present, but if this is already an `None`, it remains unchanged.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let option0: Option<200n> = Some(200n);\r\n     *  let option1: Option<201n> = option.map(value => {\r\n     *      /// Task is run because `Option` is `Some`.\r\n     *      /// ...\r\n     *      return value + 1n;\r\n     *  });\r\n     * ```\r\n     */\r\n    map<T2>(task: Closure<[T1], T2>): Some<T2>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Converts an `Option<T1>` to a `Result<T1, T2>`.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let option: Option<200n>;\r\n     *  let result: Result<200n, 404n> = option.toResult(404n);\r\n     * ```\r\n     */\r\n    toResult(__: unknown): Ok<T1>;\r\n};\r\n\r\n/**\r\n * ***Brief***\r\n * The value within an `Option`.\r\n */\r\nexport function Some<T1>(_value: T1): Some<T1> {\r\n    /** @constructor */ {\r\n        return {\r\n            type,\r\n            some,\r\n            none,\r\n            expect,\r\n            unwrap,\r\n            unwrapOr,\r\n            and,\r\n            map,\r\n            toResult\r\n        };\r\n    }\r\n\r\n    function type(): \"Some\" {\r\n        return \"Some\";\r\n    }\r\n\r\n    function some(): this is Some<T1> {\r\n        return true;\r\n    }\r\n\r\n    function none(): this is None {\r\n        return false;\r\n    }\r\n\r\n    function expect(): T1;\r\n    function expect(__: unknown): T1;\r\n    function expect(__?: unknown): T1 {\r\n        return _value;\r\n    }\r\n\r\n    function unwrap(): T1 {\r\n        return _value;\r\n    }\r\n\r\n    function unwrapOr(__: unknown): T1 {\r\n        return _value;\r\n    }\r\n\r\n    function and<T2>(task: Closure<[T1], Option<T2>>): Option<T2> {\r\n        return task(_value);\r\n    }\r\n\r\n    function map<T2>(task: Closure<[T1], T2>): Some<T2> {\r\n        return Some(task(_value));\r\n    }\r\n\r\n    function toResult(__: unknown): Ok<T1> {\r\n        return Ok(_value);\r\n    }\r\n}\r\n\r\nexport namespace Some {\r\n    export type From<T1 extends Option<unknown>> = T1 extends Some<infer T2> ? Some<T2> : never;\r\n\r\n    export type FromAll<T1 extends Array<Option<unknown>>> = {\r\n        [T2 in keyof T1]: T1[T2] extends Some<unknown> ? From<T1[T2]> : never\r\n    };\r\n\r\n    export type ValFrom<T1 extends Option<unknown>> = T1 extends Some<infer T2> ? T2 : never;\r\n\r\n    export type ValFromAll<T1 extends Array<Option<unknown>>> = {\r\n        [T2 in keyof T1]: ValFrom<T1[T2]>;\r\n    };\r\n}\r\n\r\nexport type None = \r\n    & Branded<\"None\">\r\n    & {\r\n\r\n    /**\r\n     * ***Brief***\r\n     * `some` checks if the current instance is `Some`.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let option: Option<200n>;\r\n     *  if (option.some()) {\r\n     *      let value: 200n = option.unlock();\r\n     *      /// ...\r\n     *  }\r\n     * ```\r\n     */\r\n    some(): this is Some<unknown>;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * `none` checks if the current instance is `None`.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let option: Option<200n>;\r\n     *  if (option.none()) {\r\n     *      /// `Option` cannot `unlock` because it is `None`.\r\n     *      /// ...\r\n     *  }\r\n     * ```\r\n     */\r\n    none(): this is None;\r\n    \r\n    /**\r\n     * ***Brief***\r\n     * `expect` terminates with `panic` if the `Option` is `None`.\r\n     * \r\n     * ***Warning***\r\n     * Reserved for debugging or unrecoverable errors.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let option: Option<200n>;\r\n     *  let status: 200n = option.expect(\"This is unexpected and unrecoverable.\");\r\n     * ```\r\n     */\r\n    expect(): never;\r\n    expect(message: string): never;\r\n    expect(message?: string): never;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Retrieves the value of a `Some`, or falls back to the provided value if its `None`.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let option: Option<200n> = None;\r\n     *  let status: 200n = option.unwrapOr(200n);\r\n     *  console.log(status); /// 200n.\r\n     * ```\r\n     */\r\n    unwrapOr<T2>(fallback: T2): T2;\r\n    \r\n    /**\r\n     * ***Brief***\r\n     * Chains an task until the first `None` is encountered.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let option: Option<200n> = None;\r\n     *  option\r\n     *      .and(value => {\r\n     *          /// Task is skipped because `Option` is `None`.\r\n     *          /// ...\r\n     *          return Some(value + 1n);\r\n     *      })\r\n     *      .and(value => {\r\n     *          /// Task is skipped because `Option` is `None`.\r\n     *          /// ...\r\n     *      });\r\n     * ```\r\n     */\r\n    and(__: unknown): None;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Transforms the `Some` value if present, but if this is already an `None`, it remains unchanged.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let option0: Option<200n> = Some(200n);\r\n     *  let option1: Option<201n> = option.map(value => {\r\n     *      /// Task is run because `Option` is `Some`.\r\n     *      /// ...\r\n     *      return value + 1n;\r\n     *  });\r\n     * ```\r\n     */\r\n    map(__: unknown): None;\r\n\r\n    /**\r\n     * ***Brief***\r\n     * Converts an `Option<T1>` to a `Result<T1, T2>`.\r\n     * \r\n     * ***Example***\r\n     * ```ts\r\n     *  let option: Option<200n>;\r\n     *  let result: Result<200n, 404n> = option.toResult(404n);\r\n     * ```\r\n     */\r\n    toResult<T1>(e: T1): Err<T1>;\r\n};\r\n\r\n/**\r\n * ***Brief***\r\n * The absence of a value or an \"empty\" state.\r\n * \r\n * ***Warning***\r\n * Any operation attempting to access an `Option` must safely handle the `None` state or terminate with an error.\r\n */\r\nexport const None: None = (() => {\r\n    let _this: None;\r\n\r\n    /** @constructor */ {\r\n        return _this = {\r\n            type,\r\n            some,\r\n            none,\r\n            expect,\r\n            unwrapOr,\r\n            and,\r\n            map,\r\n            toResult\r\n        };\r\n    }\r\n\r\n    function type(): \"None\" {\r\n        return \"None\";\r\n    }\r\n    \r\n    function some(): this is Some<unknown> {\r\n        return false;\r\n    }\r\n\r\n    function none(): this is None {\r\n        return true;\r\n    }\r\n\r\n    function expect(): never;\r\n    function expect(message: string): never;\r\n    function expect(message?: string): never {\r\n        Error.Handler.panic(Error({\r\n            code: \"PANIC\",\r\n            message: `${ message ? message : \"A missing value has caused the program to panic.\"}`,\r\n            stack: Error.Handler.localStackTrace(expect).unwrapOr(\"\")\r\n        }));\r\n    }\r\n\r\n    function unwrapOr<T1>(fallback: T1): T1 {\r\n        return fallback;\r\n    }\r\n\r\n    function and(__: unknown): None {\r\n        return _this;\r\n    }\r\n\r\n    function map(__: unknown): None {\r\n        return _this;\r\n    }\r\n\r\n    function toResult<T1>(e: T1): Err<T1> {\r\n        return Err(e);\r\n    }\r\n})();\r\n\r\nexport const flag: typeof Option.Handler.flag = Option.Handler.flag;\r\n\r\nexport const allO: typeof Option.Handler.all = Option.Handler.all;\r\n\r\nexport const anyO: typeof Option.Handler.any = Option.Handler.any;\r\n\r\nexport const allR: typeof Result.Handler.all = Result.Handler.all;\r\n\r\nexport const anyR: typeof Result.Handler.any = Result.Handler.any;\r\n\r\nexport const wrap: typeof Result.Handler.wrap = Result.Handler.wrap;\r\n\r\nexport const wrapAsync: typeof Result.Handler.wrapAsync = Result.Handler.wrapAsync;","export const INTERNAL_ERROR_MESSAGE: string = \"\"\r\n    + \"\\n\" + \"Uh-oh, looks like Reliq took a wrong turn!\"\r\n    + \"\\n\" + \"Don't worry, it's not you-it's us.\"\r\n    + \"\\n\" + \"Please report this at dreamcatcher_foundation@proton.me\";"],"mappings":"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","names":["BrandedStruct","Branded","Fpv","DomError","Exception","Option","Error","stack","Result","wrap","wrapAsync","e","flag"]}